"""Type-safe data models for SQLite persistence layer.

Provides dataclass models with validation and serialization helpers
for database operations. Models follow SQLAlchemy-style patterns
but use raw sqlite3 for simplicity.
"""

from dataclasses import dataclass, field, asdict
from datetime import datetime
from typing import Dict, Any, Optional
from enum import Enum
import json


class JobStatus(Enum):
    """Enumeration of possible job states."""

    QUEUED = "queued"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


@dataclass
class Race:
    """Represents a NASCAR race event.

    Attributes:
        id: Unique identifier (auto-generated by database)
        track_name: Name of the race track (e.g., "Daytona International Speedway")
        race_date: Date of the race in ISO format (YYYY-MM-DD)
        created_at: Timestamp when the record was created
    """

    id: int
    track_name: str
    race_date: str
    created_at: datetime

    def __post_init__(self):
        """Validate fields after initialization."""
        if not self.track_name or not isinstance(self.track_name, str):
            raise ValueError("track_name must be a non-empty string")
        if not self.race_date or not isinstance(self.race_date, str):
            raise ValueError("race_date must be a non-empty string")
        if not isinstance(self.created_at, datetime):
            raise ValueError("created_at must be a datetime object")

    def to_dict(self) -> Dict[str, Any]:
        """Convert Race to dictionary for database insertion.

        Returns:
            Dictionary with track_name and race_date (excludes id and created_at
            as these are auto-generated by database).
        """
        return {
            "track_name": self.track_name,
            "race_date": self.race_date,
        }

    @classmethod
    def from_row(cls, row: Any) -> "Race":
        """Create Race instance from sqlite3 Row.

        Args:
            row: sqlite3.Row object from database query

        Returns:
            Race instance populated from row data
        """
        created_at = row["created_at"]
        if isinstance(created_at, str):
            created_at = datetime.fromisoformat(created_at.replace("Z", "+00:00"))

        return cls(
            id=row["id"],
            track_name=row["track_name"],
            race_date=row["race_date"],
            created_at=created_at,
        )

    @classmethod
    def create(cls, track_name: str, race_date: str) -> "Race":
        """Factory method to create a new Race (before database insertion).

        Args:
            track_name: Name of the race track
            race_date: Date of the race (YYYY-MM-DD format)

        Returns:
            Race instance with id=0 (will be assigned by database)
        """
        return cls(
            id=0,  # Will be assigned by database
            track_name=track_name,
            race_date=race_date,
            created_at=datetime.now(),
        )


@dataclass
class Lineup:
    """Represents a saved DFS lineup configuration.

    Attributes:
        id: Unique identifier (auto-generated by database)
        race_id: Foreign key referencing the race this lineup is for
        lineup_data: Dictionary containing driver selections and metadata
        created_at: Timestamp when the lineup was saved
    """

    id: int
    race_id: int
    lineup_data: Dict[str, Any]
    created_at: datetime

    def __post_init__(self):
        """Validate fields after initialization."""
        if not isinstance(self.race_id, int) or self.race_id <= 0:
            raise ValueError("race_id must be a positive integer")
        if not isinstance(self.lineup_data, dict):
            raise ValueError("lineup_data must be a dictionary")
        if not isinstance(self.created_at, datetime):
            raise ValueError("created_at must be a datetime object")

    def to_dict(self) -> Dict[str, Any]:
        """Convert Lineup to dictionary for database insertion.

        Returns:
            Dictionary with race_id and JSON-serialized lineup_data.
        """
        return {
            "race_id": self.race_id,
            "lineup_data": json.dumps(self.lineup_data),
        }

    @classmethod
    def from_row(cls, row: Any) -> "Lineup":
        """Create Lineup instance from sqlite3 Row.

        Args:
            row: sqlite3.Row object from database query

        Returns:
            Lineup instance populated from row data
        """
        created_at = row["created_at"]
        if isinstance(created_at, str):
            created_at = datetime.fromisoformat(created_at.replace("Z", "+00:00"))

        lineup_data = row["lineup_data"]
        if isinstance(lineup_data, str):
            lineup_data = json.loads(lineup_data)

        return cls(
            id=row["id"],
            race_id=row["race_id"],
            lineup_data=lineup_data,
            created_at=created_at,
        )

    @classmethod
    def create(cls, race_id: int, lineup_data: Dict[str, Any]) -> "Lineup":
        """Factory method to create a new Lineup (before database insertion).

        Args:
            race_id: ID of the race this lineup is for
            lineup_data: Dictionary with driver selections and metadata

        Returns:
            Lineup instance with id=0 (will be assigned by database)
        """
        return cls(
            id=0,  # Will be assigned by database
            race_id=race_id,
            lineup_data=lineup_data,
            created_at=datetime.now(),
        )


@dataclass
class OptimizationConfig:
    """Represents a saved optimization configuration preset.

    Attributes:
        id: Unique identifier (auto-generated by database)
        name: Unique name for this configuration preset
        config_data: Dictionary containing optimization parameters
        created_at: Timestamp when the configuration was saved
    """

    id: int
    name: str
    config_data: Dict[str, Any]
    created_at: datetime

    def __post_init__(self):
        """Validate fields after initialization."""
        if not self.name or not isinstance(self.name, str):
            raise ValueError("name must be a non-empty string")
        if not isinstance(self.config_data, dict):
            raise ValueError("config_data must be a dictionary")
        if not isinstance(self.created_at, datetime):
            raise ValueError("created_at must be a datetime object")

    def to_dict(self) -> Dict[str, Any]:
        """Convert OptimizationConfig to dictionary for database insertion.

        Returns:
            Dictionary with name and JSON-serialized config_data.
        """
        return {
            "name": self.name,
            "config_data": json.dumps(self.config_data),
        }

    @classmethod
    def from_row(cls, row: Any) -> "OptimizationConfig":
        """Create OptimizationConfig instance from sqlite3 Row.

        Args:
            row: sqlite3.Row object from database query

        Returns:
            OptimizationConfig instance populated from row data
        """
        created_at = row["created_at"]
        if isinstance(created_at, str):
            created_at = datetime.fromisoformat(created_at.replace("Z", "+00:00"))

        config_data = row["config_data"]
        if isinstance(config_data, str):
            config_data = json.loads(config_data)

        return cls(
            id=row["id"],
            name=row["name"],
            config_data=config_data,
            created_at=created_at,
        )

    @classmethod
    def create(cls, name: str, config_data: Dict[str, Any]) -> "OptimizationConfig":
        """Factory method to create a new OptimizationConfig (before database insertion).

        Args:
            name: Unique name for this configuration
            config_data: Dictionary with optimization parameters

        Returns:
            OptimizationConfig instance with id=0 (will be assigned by database)
        """
        return cls(
            id=0,  # Will be assigned by database
            name=name,
            config_data=config_data,
            created_at=datetime.now(),
        )


@dataclass
class AppState:
    """Represents a key-value pair for application state persistence.

    Used for storing window geometry, last viewed race, and other
    application state that should persist across launches.

    Attributes:
        key: Unique identifier for this state entry
        value: Dictionary containing the state data
        updated_at: Timestamp when the state was last updated
    """

    key: str
    value: Dict[str, Any]
    updated_at: datetime

    def __post_init__(self):
        """Validate fields after initialization."""
        if not self.key or not isinstance(self.key, str):
            raise ValueError("key must be a non-empty string")
        if not isinstance(self.value, dict):
            raise ValueError("value must be a dictionary")
        if not isinstance(self.updated_at, datetime):
            raise ValueError("updated_at must be a datetime object")

    def to_dict(self) -> Dict[str, Any]:
        """Convert AppState to dictionary for database insertion.

        Returns:
            Dictionary with key and JSON-serialized value.
        """
        return {
            "key": self.key,
            "value": json.dumps(self.value),
        }

    @classmethod
    def from_row(cls, row: Any) -> "AppState":
        """Create AppState instance from sqlite3 Row.

        Args:
            row: sqlite3.Row object from database query

        Returns:
            AppState instance populated from row data
        """
        updated_at = row["updated_at"]
        if isinstance(updated_at, str):
            updated_at = datetime.fromisoformat(updated_at.replace("Z", "+00:00"))

        value = row["value"]
        if isinstance(value, str):
            value = json.loads(value)

        return cls(key=row["key"], value=value, updated_at=updated_at)

    @classmethod
    def create(cls, key: str, value: Dict[str, Any]) -> "AppState":
        """Factory method to create a new AppState entry.

        Args:
            key: Unique identifier for this state entry
            value: Dictionary containing the state data

        Returns:
            AppState instance ready for database insertion
        """
        return cls(key=key, value=value, updated_at=datetime.now())

    def get(self, subkey: str, default: Any = None) -> Any:
        """Get a value from the state dictionary.

        Args:
            subkey: Key to look up in the value dictionary
            default: Default value if key not found

        Returns:
            Value from dictionary or default
        """
        return self.value.get(subkey, default)


@dataclass
class Job:
    """Represents a background optimization job.

    Attributes:
        id: Unique identifier (UUID string)
        name: Human-readable job name (e.g., "Talladega GPP")
        status: Current job status (queued/running/completed/failed/cancelled)
        config_json: JSON-serialized optimization configuration
        result_json: JSON-serialized optimization results (null until complete)
        created_at: Timestamp when job was created
        started_at: Timestamp when job started running (null if not started)
        completed_at: Timestamp when job finished (null if not finished)
        error_message: Error message if job failed (null if successful)
        progress_percent: Current progress percentage (0-100)
    """

    id: str
    name: str
    status: JobStatus
    config_json: Dict[str, Any]
    result_json: Optional[Dict[str, Any]] = None
    created_at: datetime = field(default_factory=datetime.now)
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    error_message: Optional[str] = None
    progress_percent: int = 0

    def __post_init__(self):
        """Validate fields after initialization."""
        if not self.id or not isinstance(self.id, str):
            raise ValueError("id must be a non-empty string")
        if not self.name or not isinstance(self.name, str):
            raise ValueError("name must be a non-empty string")
        if not isinstance(self.status, JobStatus):
            raise ValueError("status must be a JobStatus enum")
        if not isinstance(self.config_json, dict):
            raise ValueError("config_json must be a dictionary")
        if not isinstance(self.created_at, datetime):
            raise ValueError("created_at must be a datetime object")
        if self.result_json is not None and not isinstance(self.result_json, dict):
            raise ValueError("result_json must be a dictionary or None")
        if self.started_at is not None and not isinstance(self.started_at, datetime):
            raise ValueError("started_at must be a datetime object or None")
        if self.completed_at is not None and not isinstance(
            self.completed_at, datetime
        ):
            raise ValueError("completed_at must be a datetime object or None")
        if self.error_message is not None and not isinstance(self.error_message, str):
            raise ValueError("error_message must be a string or None")
        if not isinstance(self.progress_percent, int) or not (
            0 <= self.progress_percent <= 100
        ):
            raise ValueError("progress_percent must be an integer between 0 and 100")

    def to_dict(self) -> Dict[str, Any]:
        """Convert Job to dictionary for database insertion.

        Returns:
            Dictionary with job fields serialized for database.
        """
        return {
            "id": self.id,
            "name": self.name,
            "status": self.status.value,
            "config_json": json.dumps(self.config_json),
            "result_json": json.dumps(self.result_json) if self.result_json else None,
            "created_at": self.created_at.isoformat(),
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat()
            if self.completed_at
            else None,
            "error_message": self.error_message,
            "progress_percent": self.progress_percent,
        }

    @classmethod
    def from_row(cls, row: Any) -> "Job":
        """Create Job instance from sqlite3 Row.

        Args:
            row: sqlite3.Row object from database query

        Returns:
            Job instance populated from row data
        """

        def parse_datetime(dt: Any) -> Optional[datetime]:
            if dt is None:
                return None
            if isinstance(dt, str):
                return datetime.fromisoformat(dt.replace("Z", "+00:00"))
            return dt

        config_json = row["config_json"]
        if isinstance(config_json, str):
            config_json = json.loads(config_json)

        result_json = row["result_json"]
        if isinstance(result_json, str):
            result_json = json.loads(result_json)

        return cls(
            id=row["id"],
            name=row["name"],
            status=JobStatus(row["status"]),
            config_json=config_json,
            result_json=result_json,
            created_at=parse_datetime(row["created_at"]),
            started_at=parse_datetime(row["started_at"]),
            completed_at=parse_datetime(row["completed_at"]),
            error_message=row["error_message"],
            progress_percent=row["progress_percent"],
        )

    @classmethod
    def create(cls, name: str, config: Dict[str, Any]) -> "Job":
        """Factory method to create a new Job.

        Args:
            name: Human-readable job name
            config: Dictionary with optimization configuration

        Returns:
            Job instance with queued status and new UUID
        """
        import uuid

        return cls(
            id=str(uuid.uuid4()),
            name=name,
            status=JobStatus.QUEUED,
            config_json=config,
        )

    def get_duration_seconds(self) -> Optional[float]:
        """Calculate job duration in seconds.

        Returns:
            Duration in seconds if job has started, None otherwise.
            If job is still running, calculates from start to now.
            If job is complete, calculates from start to completion.
        """
        if not self.started_at:
            return None

        end_time = self.completed_at or datetime.now()
        return (end_time - self.started_at).total_seconds()

    def is_active(self) -> bool:
        """Check if job is currently active (queued or running).

        Returns:
            True if job is queued or running, False otherwise.
        """
        return self.status in (JobStatus.QUEUED, JobStatus.RUNNING)

    def is_terminal(self) -> bool:
        """Check if job has reached a terminal state.

        Returns:
            True if job is completed, failed, or cancelled.
        """
        return self.status in (
            JobStatus.COMPLETED,
            JobStatus.FAILED,
            JobStatus.CANCELLED,
        )
