"""
Property-based tests for state space invariants using Hypothesis.

These tests validate that the state space and transition operators maintain
critical invariants across random inputs generated by Hypothesis.
"""

from hypothesis import given, strategies as st
import pytest

from axiomatic_sim.state_space import (
    RaceState,
    DriverState,
    RaceSegment,
    DriverId,
)
from axiomatic_sim.transitions import (
    green_flag_transition,
    caution_transition,
    pit_cycle_transition,
    fuel_window_transition,
)


# Helper functions to generate valid test data
@st.composite
def valid_driver_states(
    composite, min_position: int = 1, max_position: int = 40
):
    """Generate valid DriverState instances."""
    position = composite(st.integers(min_value=min_position, max_value=max_position))
    fuel_level = composite(st.floats(min_value=0.0, max_value=1.0))
    tire_wear = composite(st.floats(min_value=0.0, max_value=1.0))
    laps_led = composite(st.integers(min_value=0, max_value=500))
    in_pit = composite(st.booleans())
    dnf = composite(st.booleans())

    # Ensure DNF drivers aren't in pit (invariant)
    if dnf and in_pit:
        in_pit = False

    return DriverState(
        position=position,
        fuel_level=fuel_level,
        tire_wear=tire_wear,
        laps_led=laps_led,
        in_pit=in_pit,
        dnf=dnf,
    )


@st.composite
def valid_race_states(composite, min_drivers: int = 2, max_drivers: int = 40):
    """Generate valid RaceState instances."""
    # Generate driver IDs
    num_drivers = composite(st.integers(min_value=min_drivers, max_value=max_drivers))
    driver_ids = composite(
        st.lists(
            st.text(min_size=1, max_size=10, alphabet=st.characters(whitelist_categories=('L', 'N'))),
            min_size=num_drivers,
            max_size=num_drivers,
            unique=True,
        )
    )

    # Generate race parameters
    race_length = composite(st.integers(min_value=100, max_value=500))
    lap = composite(st.integers(min_value=1, max_value=race_length))

    # Generate segment
    segment = composite(st.sampled_from(list(RaceSegment)))

    # Generate driver states with unique positions
    # We'll generate positions 1..num_drivers and shuffle them
    positions = list(range(1, num_drivers + 1))

    # Create a strategy that assigns unique positions
    def make_drivers():
        # Shuffle positions for randomness
        import random

        random.shuffle(positions)

        drivers = {}
        for i, driver_id in enumerate(driver_ids):
            drivers[driver_id] = DriverState(
                position=positions[i],
                fuel_level=0.5,  # Default to mid-race fuel
                tire_wear=0.5,  # Default to mid-race tire wear
                laps_led=0,
                in_pit=False,
                dnf=False,
            )
        return drivers

    drivers = make_drivers()

    # Handle caution segment specifics
    active_caution_laps = 0
    if segment == RaceSegment.CAUTION:
        active_caution_laps = composite(st.integers(min_value=1, max_value=10))

    return RaceState(
        lap=lap,
        race_length=race_length,
        segment=segment,
        drivers=drivers,
        active_caution_laps=active_caution_laps,
    )


# Property-based tests
@given(state=valid_race_states(min_drivers=2, max_drivers=40), laps=st.integers(min_value=1, max_value=10))
def test_lap_never_exceeds_race_length(state, laps):
    """Lap counter should never exceed race_length after green flag transition.

    Given: Random RaceState with lap <= race_length
    When: Apply green_flag_transition with random laps (1-10)
    Then: Result lap <= race_length (or raises ValueError if would exceed)
    """
    # If advancing would exceed race length, should raise ValueError
    try:
        new_state = green_flag_transition(state, laps=laps)
        assert new_state.lap <= new_state.race_length, (
            f"Lap ({new_state.lap}) exceeded race_length ({new_state.race_length})"
        )
    except ValueError as e:
        # Expected if transition would exceed race length
        assert "advance" in str(e).lower() or "exceed" in str(e).lower()


@given(state=valid_race_states(min_drivers=2, max_drivers=40))
def test_fuel_level_bounds(state):
    """All driver fuel levels should remain in [0, 1] after green flag transition.

    Given: Random RaceState
    When: Apply green_flag_transition
    Then: All driver fuel_levels in [0, 1]
    """
    try:
        new_state = green_flag_transition(state, laps=1)
        for driver_id, driver_state in new_state.drivers.items():
            if not driver_state.dnf:
                assert (
                    0.0 <= driver_state.fuel_level <= 1.0
                ), f"Driver {driver_id} fuel_level {driver_state.fuel_level} not in [0, 1]"
    except ValueError:
        # May exceed race length - that's OK for this test
        pass


@given(state=valid_race_states(min_drivers=2, max_drivers=40))
def test_caution_freezes_positions(state):
    """All driver positions should remain unchanged during caution.

    Given: RaceState with known positions
    When: Apply caution_transition
    Then: All driver positions unchanged (for non-DNF drivers)
    """
    # Record original positions
    original_positions = {
        driver_id: driver_state.position
        for driver_id, driver_state in state.drivers.items()
        if not driver_state.dnf
    }

    new_state = caution_transition(state, caution_laps=3)

    # Check positions unchanged for non-DNF drivers
    for driver_id, driver_state in new_state.drivers.items():
        if not driver_state.dnf:
            assert (
                driver_state.position == original_positions[driver_id]
            ), f"Driver {driver_id} position changed from {original_positions[driver_id]} to {driver_state.position}"


@given(
    state=valid_race_states(min_drivers=2, max_drivers=40),
    pit_count=st.integers(min_value=1, max_value=10),
)
def test_pit_cycle_resets_fuel_and_tires(state, pit_count):
    """Pitting drivers should have fuel and tires reset to 1.0.

    Given: RaceState with drivers (fuel and tire wear < 1.0)
    When: Apply pit_cycle_transition with those drivers
    Then: Pitting drivers have fuel_level = 1.0 and tire_wear = 1.0
    """
    # Get list of active drivers
    active_driver_ids = [
        driver_id
        for driver_id, driver_state in state.drivers.items()
        if not driver_state.dnf
    ]

    if not active_driver_ids:
        pytest.skip("No active drivers to test")

    # Select random subset of drivers to pit
    import random

    pit_drivers = random.sample(
        active_driver_ids, min(pit_count, len(active_driver_ids))
    )

    new_state = pit_cycle_transition(state, pit_drivers=pit_drivers)

    # Check that pitting drivers have reset fuel and tires
    for driver_id in pit_drivers:
        driver_state = new_state.drivers[driver_id]
        assert (
            driver_state.fuel_level == 1.0
        ), f"Driver {driver_id} fuel_level not reset to 1.0 after pit"
        assert (
            driver_state.tire_wear == 1.0
        ), f"Driver {driver_id} tire_wear not reset to 1.0 after pit"
        assert (
            driver_state.in_pit
        ), f"Driver {driver_id} should be marked as in_pit after pit cycle"


@given(state=valid_race_states(min_drivers=2, max_drivers=40))
def test_position_sum_conservation(state):
    """Sum of positions should equal N*(N+1)/2 (no gaps in positions).

    Given: RaceState with N drivers
    When: Apply green_flag_transition
    Then: Sum of positions = N*(N+1)/2 (triangular number)
    """
    try:
        new_state = green_flag_transition(state, laps=1)

        # Count active drivers
        active_drivers = [
            driver_state
            for driver_state in new_state.drivers.values()
            if not driver_state.dnf
        ]
        n = len(active_drivers)

        # Calculate expected sum (triangular number)
        expected_sum = n * (n + 1) // 2

        # Calculate actual sum
        actual_sum = sum(driver_state.position for driver_state in active_drivers)

        assert (
            actual_sum == expected_sum
        ), f"Position sum {actual_sum} != expected {expected_sum} for {n} drivers"
    except ValueError:
        # May exceed race length - that's OK for this test
        pass


# Additional validation tests
@given(state=valid_race_states(min_drivers=2, max_drivers=40))
def test_tire_wear_bounds(state):
    """All driver tire wear should remain in [0, 1] after green flag transition.

    Given: Random RaceState
    When: Apply green_flag_transition
    Then: All driver tire_wear in [0, 1]
    """
    try:
        new_state = green_flag_transition(state, laps=1)
        for driver_id, driver_state in new_state.drivers.items():
            if not driver_state.dnf:
                assert (
                    0.0 <= driver_state.tire_wear <= 1.0
                ), f"Driver {driver_id} tire_wear {driver_state.tire_wear} not in [0, 1]"
    except ValueError:
        # May exceed race length - that's OK for this test
        pass


@given(state=valid_race_states(min_drivers=2, max_drivers=40))
def test_position_uniqueness(state):
    """All active drivers should have unique positions.

    Given: RaceState
    When: Apply any transition
    Then: No two active drivers share the same position
    """
    try:
        new_state = green_flag_transition(state, laps=1)

        # Collect positions of active drivers
        positions = [
            driver_state.position
            for driver_state in new_state.drivers.values()
            if not driver_state.dnf
        ]

        # Check uniqueness
        assert len(positions) == len(
            set(positions)
        ), f"Duplicate positions found: {positions}"
    except ValueError:
        # May exceed race length - that's OK for this test
        pass


@given(state=valid_race_states(min_drivers=2, max_drivers=40))
def test_fuel_window_detection(state):
    """Fuel window should be triggered when >5 drivers below threshold.

    Given: RaceState
    When: Apply fuel_window_transition
    Then: Segment changes to FUEL_WINDOW if >5 drivers below threshold
    """
    new_state = fuel_window_transition(state)

    # Count drivers below threshold
    drivers_below_threshold = [
        driver_state
        for driver_state in new_state.drivers.values()
        if not driver_state.dnf and driver_state.fuel_level < 0.15
    ]

    if len(drivers_below_threshold) > 5:
        assert (
            new_state.segment == RaceSegment.FUEL_WINDOW
        ), f"Should be in FUEL_WINDOW with {len(drivers_below_threshold)} drivers below threshold"
    else:
        # Segment may or may not change, but state should be valid
        assert isinstance(new_state, RaceState), "State should remain valid RaceState"
