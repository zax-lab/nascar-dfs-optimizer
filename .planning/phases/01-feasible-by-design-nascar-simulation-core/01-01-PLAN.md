---
phase: 01-feasible-by-design-nascar-simulation-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/axiomatic-sim/src/state_space.py
  - packages/axiomatic-sim/src/transitions.py
  - packages/axiomatic-sim/tests/test_state_space.py
autonomous: true

must_haves:
  truths:
    - "State space model represents race as explicit transitions between green runs, caution periods, pit cycles, and fuel windows"
    - "Transition operators are composable and type-safe (prevents invalid state transitions)"
    - "State tracking includes position, lap, fuel status, and tire condition for each driver"
    - "Property-based tests validate state invariants across random inputs"
  artifacts:
    - path: "packages/axiomatic-sim/src/state_space.py"
      provides: "RaceState type and state transition operators"
      min_lines: 150
      exports: ["RaceState", "StateTransition", "TransitionOperator"]
    - path: "packages/axiomatic-sim/src/transitions.py"
      provides: "Concrete transition implementations (green, caution, pit, fuel)"
      min_lines: 200
      exports: ["green_flag_transition", "caution_transition", "pit_cycle_transition", "fuel_window_transition"]
    - path: "packages/axiomatic-sim/tests/test_state_space.py"
      provides: "Property-based tests for state invariants"
      min_lines: 100
  key_links:
    - from: "packages/axiomatic-sim/src/transitions.py"
      to: "packages/axiomatic-sim/src/state_space.py"
      via: "Import RaceState and StateTransition types"
      pattern: "from.*state_space.*import.*RaceState"
---

<objective>
Create a type-safe state space model with explicit transition operators that represent NASCAR race dynamics (green runs, caution periods, pit cycles, fuel windows).

Purpose: This is the foundation for the simulation engine. All downstream work (CBN, scenario generation, conservation validation) depends on a coherent state representation with valid transitions. The state space must be composable so transitions can be chained to build Skeleton Narratives.

Output: Typed state space module with transition operators, property-based tests validating invariants
</objective>

<execution_context>
@/Users/zax/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zax/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-feasible-by-design-nascar-simulation-core/01-CONTEXT.md
@.planning/phases/01-feasible-by-design-nascar-simulation-core/01-RESEARCH.md

# Research decisions applied from 01-RESEARCH.md:
- State variables: position, lap, fuel_level, tire_wear, current_segment
- Transitions: Event-driven (caution, pit entry) for fine granularity
- Conservation enforcement: Hybrid (feasible-by-design for strict, post-validation for soft)
- Scenario count: Start with 1,000 as minimum viable
</context>

<tasks>

<task type="auto">
  <name>Create state space core types and RaceState dataclass</name>
  <files>packages/axiomatic-sim/src/state_space.py</files>
  <action>
    Create `packages/axiomatic-sim/src/state_space.py` with:

    1. **RaceState dataclass** with fields:
       - `lap: int` (current lap number, 1-indexed)
       - `race_length: int` (total laps in race)
       - `segment: RaceSegment` (enum: GREEN_FLAG, CAUTION, PIT_CYCLE, FUEL_WINDOW)
       - `drivers: Dict[str, DriverState]` (driver_id -> DriverState)
       - `active_caution_laps: int` (laps remaining in caution, 0 if green)

    2. **DriverState dataclass** with fields:
       - `position: int` (current running position, 1-40)
       - `fuel_level: float` (0.0-1.0, fraction of fuel remaining)
       - `tire_wear: float` (0.0-1.0, fraction of tire life remaining)
       - `laps_led: int` (total laps led so far)
       - `in_pit: bool` (currently on pit road)
       - `dnf: bool` (did not finish)

    3. **RaceSegment enum**:
       - GREEN_FLAG (normal racing)
       - CAUTION (field frozen, safety vehicles on track)
       - PIT_CYCLE (green flag pit stop sequence)
       - FUEL_WINDOW (approaching fuel exhaustion)

    4. **StateTransition protocol**:
       - Method signature: `def apply(state: RaceState) -> RaceState`
       - Must return new state (immutable updates)

    5. **Type aliases**:
       - `DriverId = str`
       - `TransitionCallable = Callable[[RaceState], RaceState]`

    Use `dataclasses` with `frozen=True` for immutability. Include validation in `__post_init__` (e.g., lap ≤ race_length, fuel_level in [0,1]).

    DO NOT: Add simulation logic yet (that's in transitions.py). DO NOT: Import from apps/backend (this is a shared package).
  </action>
  <verify>
    Run `python -c "from packages.axiomatic_sim.src.state_space import RaceState, DriverState, RaceSegment; print('Imports successful')"` and verify no ImportError
  </verify>
  <done>
    RaceState and DriverState types are defined with validation, RaceSegment enum has 4 values, StateTransition protocol is callable
  </done>
</task>

<task type="auto">
  <name>Implement transition operators for green flag, caution, pit cycle, and fuel window</name>
  <files>packages/axiomatic-sim/src/transitions.py</files>
  <action>
    Create `packages/axiomatic-sim/src/transitions.py` with 4 transition functions implementing StateTransition protocol:

    1. **green_flag_transition(state: RaceState, laps: int = 1) -> RaceState**:
       - Increment lap counter by `laps` parameter
       - Decrease fuel_level for all drivers by FUEL_BURN_PER_LAP constant (0.01)
       - Increase tire_wear by TIRE_WEAR_PER_LAP constant (0.02)
       - Update positions based on random position swaps (binomial distribution, p=0.1 per lap)
       - Track laps_led for current leader
       - Validate: lap ≤ race_length, fuel_level ≥ 0

    2. **caution_transition(state: RaceState, caution_laps: int = 3) -> RaceState**:
       - Set segment to CAUTION
       - Freeze all positions (no position changes)
       - Set active_caution_laps = caution_laps
       - Decrease fuel_level by CAUTION_FUEL_BURN (0.005 per lap, slower than green)
       - Drivers in pits complete pit stop (in_pit = False after service)

    3. **pit_cycle_transition(state: RaceState, pit_drivers: List[DriverId]) -> RaceState**:
       - Set segment to PIT_CYCLE
       - For each driver in pit_drivers: set in_pit = True, reset fuel_level to 1.0, tire_wear to 1.0
       - Position penalty: pitting drivers drop to rear of field (positions 36-40 based on pit order)
       - Non-pitting drivers advance positions to fill gaps

    4. **fuel_window_transition(state: RaceState) -> RaceState**:
       - Check all drivers with fuel_level < FUEL_THRESHOLD (0.15)
       - If >5 drivers below threshold, set segment to FUEL_WINDOW
       - Return unmodified state if not in fuel window

    Each transition MUST:
    - Return new RaceState (immutable, use dataclasses.replace)
    - Validate state invariants before returning
    - Log transition with structured logging (module = "axiomatic_sim.transitions")

    Constants to define at module level:
    - FUEL_BURN_PER_LAP = 0.01
    - TIRE_WEAR_PER_LAP = 0.02
    - CAUTION_FUEL_BURN = 0.005
    - FUEL_THRESHOLD = 0.15

    Import RaceState, DriverState, RaceSegment from state_space.py.
  </action>
  <verify>
    Run `python -c "from packages.axiomatic_sim.src.transitions import green_flag_transition, caution_transition; print('Transitions imported')"` and verify all 4 transitions import successfully
  </verify>
  <done>
    All 4 transitions implemented and callable, each returns new RaceState, state invariants validated in each transition
  </done>
</task>

<task type="auto">
  <name>Create property-based tests for state space invariants using Hypothesis</name>
  <files>packages/axiomatic-sim/tests/test_state_space.py</files>
  <action>
    Create `packages/axiomatic-sim/tests/test_state_space.py` with Hypothesis property-based tests:

    1. **test_lap_never_exceeds_race_length**:
       - Given: Random RaceState with lap ≤ race_length
       - When: Apply green_flag_transition with random laps (1-10)
       - Then: Result lap ≤ race_length

    2. **test_fuel_level_bounds**:
       - Given: Random RaceState
       - When: Apply green_flag_transition
       - Then: All driver fuel_levels in [0, 1]

    3. **test_caution_freezes_positions**:
       - Given: RaceState with known positions
       - When: Apply caution_transition
       - Then: All driver positions unchanged

    4. **test_pit_cycle_resets_fuel_and_tires**:
       - Given: RaceState with pitting drivers (fuel < 1.0, tire_wear < 1.0)
       - When: Apply pit_cycle_transition with those drivers
       - Then: Pitting drivers have fuel_level = 1.0 and tire_wear = 1.0

    5. **test_position_sum_conservation**:
       - Given: RaceState with N drivers
       - When: Apply green_flag_transition
       - Then: Sum of positions = N*(N+1)/2 (triangular number, positions 1-N with no gaps)

    Use Hypothesis strategies:
    - `@given(st.integers(min_value=1, max_value=40))` for field size
    - `@given(st.integers(min_value=100, max_value=500))` for race length
    - `@given(st.lists(st.text(min_size=1, max_size=10), min_size=2, max_size=40))` for driver IDs

    Each test must:
    - Create minimal valid RaceState for the hypothesis
    - Apply single transition
    - Assert invariant holds

    Run with: `pytest packages/axiomatic-sim/tests/test_state_space.py -v`

    DO NOT: Test transition chains (that's integration testing). DO NOT: Mock external dependencies (none exist yet).
  </action>
  <verify>
    Run `pytest packages/axiomatic-sim/tests/test_state_space.py -v` and verify all 5 tests pass
  </verify>
  <done>
    All 5 property-based tests pass, Hypothesis generates diverse test cases, no test failures after 100+ examples per test
  </done>
</task>

</tasks>

<verification>
Run test suite: `pytest packages/axiomatic-sim/tests/test_state_space.py -v`

Verify imports work: `python -c "from packages.axiomatic_sim.src.state_space import RaceState; from packages.axiomatic_sim.src.transitions import green_flag_transition, caution_transition; print('All imports successful')"`

Check type hints: `mypy packages/axiomatic-sim/src/state_space.py --no-error-summary 2>&1 | head -20` (should have no critical errors)
</verification>

<success_criteria>
1. RaceState and DriverState types defined with validation (frozen dataclasses)
2. All 4 transitions (green, caution, pit, fuel) implemented and callable
3. Property-based tests validate 5 core invariants (lap bounds, fuel bounds, position freezing, pit reset, position conservation)
4. Code follows type safety (mypy clean with no critical errors)
5. All tests pass with 100+ Hypothesis examples per test
</success_criteria>

<output>
After completion, create `.planning/phases/01-feasible-by-design-nascar-simulation-core/01-01-SUMMARY.md`
</output>
