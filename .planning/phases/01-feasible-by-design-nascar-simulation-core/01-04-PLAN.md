---
phase: 01-feasible-by-design-nascar-simulation-core
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - apps/backend/app/kernel.py
  - packages/axiomatic-sim/src/conservation.py
  - apps/backend/tests/test_kernel_conservation.py
autonomous: true

must_haves:
  truths:
    - "Kernel validates dominator conservation (total laps led ≤ race length, total fastest laps ≤ green flag laps)"
    - "Kernel logs veto reasons clearly when conservation violated"
    - "Position swap plausibility validated (max swaps bounded by physical limits)"
    - "Property-based tests validate conservation invariants"
  artifacts:
    - path: "apps/backend/app/kernel.py"
      provides: "Extended kernel with dominator conservation validation"
      min_lines: 220
      exports: ["KernelLogic", "validate_dominator_conservation", "validate_position_swaps", "ConservationResult"]
    - path: "packages/axiomatic-sim/src/conservation.py"
      provides: "Conservation validation utilities with JAX acceleration"
      min_lines: 160
      exports: ["validate_laps_led_conservation", "validate_fastest_laps_conservation", "calculate_max_position_swaps", "batch_validate_conservation"]
    - path: "apps/backend/tests/test_kernel_conservation.py"
      provides: "Property-based tests for kernel conservation validation"
      min_lines: 130
  key_links:
    - from: "apps/backend/app/kernel.py"
      to: "packages/axiomatic-sim/src/conservation.py"
      via: "Import validation utilities for dominator conservation"
      pattern: "from.*conservation.*import.*validate_laps_led_conservation"
    - from: "packages/axiomatic-sim/src/scenario_generator.py"
      to: "apps/backend/app/kernel.py"
      via: "Generate scenarios then call kernel.validate_dominator_conservation for post-validation"
      pattern: "kernel\.validate_dominator_conservation\("
    - from: "packages/axiomatic-sim/src/conservation.py"
      to: "packages/axiomatic-sim/src/state_space.py"
      via: "Validate RaceState invariants using JAX"
      pattern: "from.*state_space.*import.*RaceState"
---

<objective>
Extend Kernel to enforce dominator conservation constraints with JAX-accelerated validation, providing veto reasons and supporting batch validation across scenarios.

Purpose: The Kernel is the final arbiter that prevents impossible states from propagating to optimization. Conservation validation ensures scenarios don't inflate dominator totals (impossible worlds). This is the "axiomatic" enforcement that makes the system mechanically plausible.

Output: Extended kernel module with conservation validation, conservation utilities module with JAX, property-based tests
</objective>

<execution_context>
@/Users/zax/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zax/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-feasible-by-design-nascar-simulation-core/01-CONTEXT.md
@.planning/phases/01-feasible-by-design-nascar-simulation-core/01-RESEARCH.md
@.planning/phases/01-feasible-by-design-nascar-simulation-core/01-01-PLAN.md
@/Users/zax/Desktop/nascar-model copy 2/apps/backend/app/kernel.py

# Research decisions applied from 01-RESEARCH.md:
- Conservation enforcement: Hybrid (feasible-by-design for strict, post-validation for soft)
- Performance: JAX vectorization for batch validation across 1,000+ scenarios
- Veto logging: Clear reasons for each validation failure
</context>

<tasks>

<task type="auto">
  <name>Create conservation validation utilities with JAX acceleration</name>
  <files>packages/axiomatic-sim/src/conservation.py</files>
  <action>
    Create `packages/axiomatic-sim/src/conservation.py` with JAX-accelerated validation:

    1. **validate_laps_led_conservation function**:
       - Signature: `def validate_laps_led_conservation(laps_led: jax.Array, race_length: int) -> Tuple[bool, str]`
       - Input: JAX array of laps_led per driver (shape: [n_drivers])
       - Check: sum(laps_led) ≤ race_length
       - Return: (is_valid, veto_reason if invalid else "")

    2. **validate_fastest_laps_conservation function**:
       - Signature: `def validate_fastest_laps_conservation(fastest_laps: jax.Array, green_flag_laps: int) -> Tuple[bool, str]`
       - Input: JAX array of fastest_laps per driver
       - Check: sum(fastest_laps) ≤ green_flag_laps
       - Return: (is_valid, veto_reason if invalid else "")

    3. **calculate_max_position_swaps function**:
       - Signature: `def calculate_max_position_swaps(field_size: int, green_flag_laps: int) -> int`
       - Calculate physical limit on position swaps per race
       - Formula: min(field_size * 2, green_flag_laps // 10)
       - Rationale: Max 2 position changes per driver per green flag segment, limited by track opportunities
       - Return: max_swaps (integer)

    4. **validate_position_swaps function**:
       - Signature: `def validate_position_swaps(start_positions: jax.Array, finish_positions: jax.Array, max_swaps: int) -> Tuple[bool, str]`
       - Input: Start and finish position arrays
       - Check: sum(abs(finish - start)) ≤ max_swaps * field_size
       - Rationale: Total position changes across all drivers bounded by physical opportunities
       - Return: (is_valid, veto_reason if invalid else "")

    5. **batch_validate_conservation function (JAX-compiled)**:
       - Signature: `@jax.jit def batch_validate_conservation(scenarios: jax.Array) -> jax.Array`
       - Input: Batch of scenarios with laps_led and fastest_laps (shape: [n_scenarios, n_drivers, 2])
       - Vectorize validation across all scenarios
       - Return: Boolean array (shape: [n_scenarios]) indicating valid/invalid

    6. **ConservationResult dataclass**:
       - `laps_led_valid: bool`
       - `fastest_laps_valid: bool`
       - `position_swaps_valid: bool`
       - `veto_reasons: List[str]` (populated if any validation fails)
       - `is_valid: bool` (True only if all validations pass)

    Import JAX for acceleration:
    - `import jax.numpy as jnp`
    - `import jax`
    - `from jax import vmap, jit`

    Import from state_space:
    - `from packages.axiomatic_sim.src.state_space import RaceState`

    DO NOT: Implement KernelLogic class (that's in kernel.py). DO NOT: Handle lineups (that's DFS validation, Phase 3).
  </action>
  <verify>
    Run `python -c "from packages.axiomatic_sim.src.conservation import validate_laps_led_conservation, calculate_max_position_swaps; print('Conservation module imports successfully')"` (may have JAX import error if not installed, that's OK for now)
  </verify>
  <done>
    All 5 validation functions implemented, batch_validate_conservation JIT-compiled, ConservationResult dataclass defined with veto reasons
  </done>
</task>

<task type="auto">
  <name>Extend Kernel with dominator conservation validation</name>
  <files>apps/backend/app/kernel.py</files>
  <action>
    Extend `apps/backend/app/kernel.py` (existing file) with conservation validation:

    1. **Add new imports** at top of file:
       ```python
       from typing import Dict, List, Optional, Tuple
       from dataclasses import dataclass
       import logging

       # Import conservation utilities
       try:
           from packages.axiomatic_sim.src.conservation import (
               validate_laps_led_conservation,
               validate_fastest_laps_conservation,
               validate_position_swaps,
               calculate_max_position_swaps,
               ConservationResult
           )
       except ImportError:
           # Standalone usage fallback
           from .conservation_fallback import (
               validate_laps_led_conservation,
               validate_fastest_laps_conservation,
               validate_position_swaps,
               calculate_max_position_swaps,
               ConservationResult
           )
       ```

    2. **Add ConservationResult dataclass** (if not imported):
       ```python
       @dataclass
       class ConservationResult:
           laps_led_valid: bool
           fastest_laps_valid: bool
           position_swaps_valid: bool
           veto_reasons: List[str]
           is_valid: bool

           def __post_init__(self):
               self.is_valid = all([
                   self.laps_led_valid,
                   self.fastest_laps_valid,
                   self.position_swaps_valid
               ])
       ```

    3. **Add validate_dominator_conservation method to KernelLogic class**:
       - Signature: `def validate_dominator_conservation(self, scenario_data: Dict[str, any]) -> ConservationResult`
       - Extract from scenario_data:
         - `laps_led: Dict[str, int]` (driver_id -> laps led)
         - `fastest_laps: Dict[str, int]` (driver_id -> fastest laps)
         - `start_positions: Dict[str, int]` (driver_id -> starting position)
         - `finish_positions: Dict[str, int]` (driver_id -> finish position)
         - `race_length: int`
         - `green_flag_laps: int`
       - Convert dicts to JAX arrays
       - Call validate_laps_led_conservation
       - Call validate_fastest_laps_conservation
       - Calculate max_position_swaps
       - Call validate_position_swaps
       - Collect veto_reasons from failed validations
       - Return ConservationResult

    4. **Add validate_position_swaps method (wrapper)**:
       - Signature: `def validate_position_swaps(self, start_positions: List[int], finish_positions: List[int]) -> Tuple[bool, str]`
       - Convert lists to JAX arrays
       - Calculate max swaps via calculate_max_position_swaps
       - Call validation utility
       - Return (is_valid, veto_reason)

    5. **Add batch validation method**:
       - Signature: `def batch_validate_scenarios(self, scenarios: List[Dict[str, any]]) -> List[ConservationResult]`
       - Convert scenarios to batch format for JAX
       - Use vmap to validate all scenarios in parallel
       - Return list of ConservationResult

    6. **Add logging for veto reasons**:
       - Use `logging.getLogger(__name__)` for structured logging
       - Log each validation failure with:
         - Scenario ID (if available)
         - Violated constraint (laps_led, fastest_laps, position_swaps)
         - Actual vs expected values
         - Human-readable veto reason
       - Log at WARNING level for invalid scenarios

    7. **Add Kernel version tracking**:
       - Add class attribute: `VERSION = "1.1.0"` (increment from existing)
       - Add method: `def get_version(self) -> str` to return version

    Preserve existing KernelLogic methods (validate_position, validate_lineup_positions, etc.) - do not modify or remove them.

    DO NOT: Modify existing validation logic (only add new methods). DO NOT: Implement DFS rules compliance (that's Phase 3).
  </action>
  <verify>
    Run `python -c "from apps.backend.app.kernel import KernelLogic; k = KernelLogic(); print(f'Kernel version: {k.get_version()}'); print('Conservation validation method exists:', hasattr(k, 'validate_dominator_conservation'))"`
  </verify>
  <done>
    KernelLogic extended with 3 new methods, validate_dominator_conservation calls all validation utilities, veto reasons logged clearly, batch validation uses JAX vmap
  </done>
</task>

<task type="auto">
  <name>Create property-based tests for kernel conservation validation</name>
  <files>apps/backend/tests/test_kernel_conservation.py</files>
  <action>
    Create `apps/backend/tests/test_kernel_conservation.py` with Hypothesis tests:

    1. **test_laps_led_conservation_when_sum_equals_race_length**:
       - Given: Random field_size (2-40), race_length (100-500)
       - When: Generate laps_led that sum exactly to race_length
       - Then: validate_laps_led_conservation returns (True, "")

    2. **test_laps_led_conservation_when_sum_exceeds_race_length**:
       - Given: Random field_size, race_length
       - When: Generate laps_led that sum to race_length + 1
       - Then: validate_laps_led_conservation returns (False, veto_reason containing "laps_led")

    3. **test_fastest_laps_conservation_when_sum_equals_green_flag_laps**:
       - Given: Random field_size, green_flag_laps
       - When: Generate fastest_laps that sum exactly to green_flag_laps
       - Then: validate_fastest_laps_conservation returns (True, "")

    4. **test_position_swaps_within_physical_limit**:
       - Given: Random field_size, green_flag_laps
       - When: Generate start/finish positions with swaps ≤ max_swaps
       - Then: validate_position_swaps returns (True, "")

    5. **test_position_swaps_exceeds_physical_limit**:
       - Given: Random field_size, green_flag_laps
       - When: Generate start/finish positions with swaps > max_swaps
       - Then: validate_position_swaps returns (False, veto_reason containing "position_swaps")

    6. **test_kernel_validate_dominator_conservation_integration**:
       - Given: KernelLogic instance, scenario_data with all conserved values
       - When: Call validate_dominator_conservation
       - Then: ConservationResult.is_valid is True

    7. **test_kernel_batch_validation_efficiency**:
       - Given: KernelLogic instance, 1,000 scenarios
       - When: Call batch_validate_scenarios
       - Then: Completes in <5 seconds (JAX vectorization effective)

    Use Hypothesis strategies:
    - `@given(st.integers(min_value=2, max_value=40))` for field_size
    - `@given(st.integers(min_value=100, max_value=500))` for race_length
    - `@given(st.lists(st.integers(min_value=0, max_value=100), min_size=2, max_size=40))` for laps_led

    Mock JAX if not available:
    - Use `unittest.mock.patch` for JAX imports
    - Test logic without actual JAX execution

    Run with: `pytest apps/backend/tests/test_kernel_conservation.py -v`

    DO NOT: Test existing KernelLogic methods (covered in test_kernel.py). DO NOT: Test scenario generation (that's test_scenario_generator.py).
  </action>
  <verify>
    Run `pytest apps/backend/tests/test_kernel_conservation.py -v` and verify all 7 tests pass
  </verify>
  <done>
    All 7 property-based tests pass, conservation validated for conserved scenarios, violations detected and veto_reasons populated, batch validation performs efficiently
  </done>
</task>

</tasks>

<verification>
Run test suite: `pytest apps/backend/tests/test_kernel_conservation.py -v`

Integration test: Validate scenario conservation:
```bash
python -c "
from apps.backend.app.kernel import KernelLogic
import jax.numpy as jnp

kernel = KernelLogic(field_size=40)

# Test conserved scenario
laps_led = jnp.array([100, 50, 30, 20, 10, 5] + [0] * 34)
fastest_laps = jnp.array([10, 8, 5, 3, 2, 1] + [0] * 34)
race_length = 200
green_flag_laps = 180

result = kernel.validate_dominator_conservation({
    'laps_led': laps_led,
    'fastest_laps': fastest_laps,
    'start_positions': jnp.arange(1, 41),
    'finish_positions': jnp.arange(1, 41),
    'race_length': race_length,
    'green_flag_laps': green_flag_laps
})

print(f'Conservation valid: {result.is_valid}')
print(f'Veto reasons: {result.veto_reasons}')
"
```

Check JAX performance: `python -c "import jax; import time; t0 = time.time(); jax.numpy.sum(jax.numpy.ones(1000000)).block_until_ready(); print(f'JAX operation time: {time.time() - t0:.3f}s')"`
</verification>

<success_criteria>
1. Conservation utilities module with 5 validation functions
2. KernelLogic extended with 3 new conservation methods
3. validate_dominator_conservation checks laps_led, fastest_laps, position_swaps
4. Veto reasons logged clearly for each validation failure
5. batch_validate_scenarios uses JAX vmap for parallel validation
6. Property-based tests validate conservation invariants across random inputs
7. Batch validation of 1,000 scenarios completes in <5 seconds
</success_criteria>

<output>
After completion, create `.planning/phases/01-feasible-by-design-nascar-simulation-core/01-04-SUMMARY.md`
</output>
