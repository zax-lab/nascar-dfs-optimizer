---
phase: 01-feasible-by-design-nascar-simulation-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/axiomatic-sim/src/ontology_constraints.py
  - packages/axiomatic-sim/src/cbn.py
  - packages/axiomatic-sim/tests/test_ontology_constraints.py
autonomous: true

must_haves:
  truths:
    - "Ontology provides priors for CBN variables (driver skill, track difficulty, car quality)"
    - "Veto rules prevent impossible CBN edges (e.g., DNF driver cannot lead laps after incident)"
    - "CBN structure is constrained by ontology before parameter learning"
    - "Property-based tests validate veto rule enforcement"
  artifacts:
    - path: "packages/axiomatic-sim/src/ontology_constraints.py"
      provides: "Ontology constraint extraction and veto rule enforcement"
      min_lines: 180
      exports: ["OntologyConstraints", "VetoRule", "get_driver_priors", "apply_veto_rules"]
    - path: "packages/axiomatic-sim/src/cbn.py"
      provides: "Causal Bayesian Network with pgmpy, structure constrained by ontology"
      min_lines: 220
      exports: ["CausalBayesianNetwork", "learn_structure", "apply_ontology_constraints", "sample_conditional_outcomes"]
    - path: "packages/axiomatic-sim/tests/test_ontology_constraints.py"
      provides: "Property-based tests for veto rules and priors"
      min_lines: 120
  key_links:
    - from: "packages/axiomatic-sim/src/cbn.py"
      to: "packages/axiomatic-sim/src/ontology_constraints.py"
      via: "Import OntologyConstraints and VetoRule to apply veto rules"
      pattern: "from.*ontology_constraints.*import.*OntologyConstraints"
    - from: "packages/axiomatic-sim/src/cbn.py"
      to: "apps/backend/app/ontology.py"
      via: "Use OntologyDriver to fetch driver metaphysical properties for priors"
      pattern: "from.*ontology.*import.*OntologyDriver"
---

<objective>
Build ontology constraint layer that provides priors and veto rules for the Causal Bayesian Network, constraining CBN structure to prevent impossible race states.

Purpose: The ontology grounds the CBN in domain knowledge (driver skill, track characteristics) and prevents impossible causal relationships (e.g., DNF driver leading laps post-incident). This is the "axiomatic" enforcement that distinguishes this system from unconstrained ML.

Output: Ontology constraints module with veto rules, CBN module with pgmpy integration constrained by ontology, property-based tests
</objective>

<execution_context>
@/Users/zax/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zax/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-feasible-by-design-nascar-simulation-core/01-CONTEXT.md
@.planning/phases/01-feasible-by-design-nascar-simulation-core/01-RESEARCH.md
@/Users/zax/Desktop/nascar-model copy 2/apps/backend/app/ontology.py

# Research decisions applied from 01-RESEARCH.md:
- CBN parameterization: Hybrid (ontology for skill priors, learn transitions from data)
- CBN depth: Simplified DBN (latent factors for temporal dynamics, not full per-lap granularity)
- Veto rules: Hard constraints on CBN structure (remove impossible edges)
- Uncertainty: Bayesian parameter learning with ontology priors
</context>

<tasks>

<task type="auto">
  <name>Create ontology constraints module with veto rules</name>
  <files>packages/axiomatic-sim/src/ontology_constraints.py</files>
  <action>
    Create `packages/axiomatic-sim/src/ontology_constraints.py` with:

    1. **VetoRule dataclass**:
       - `source: str` (source variable in CBN)
       - `target: str` (target variable in CBN)
       - `reason: str` (human-readable explanation)
       - Example: (source="DNF", target="laps_led_after_incident", reason="DNF driver cannot lead laps after incident")

    2. **OntologyConstraints class** with methods:
       - `__init__(self, ontology_driver: OntologyDriver)`:
         - Store OntologyDriver reference
         - Load driver skill priors from Neo4j
         - Load track difficulty from Neo4j

       - `get_driver_priors(self, driver_id: str) -> Dict[str, float]`:
         - Fetch driver node from ontology
         - Return dict: {"skill": driver.skill, "aggression": driver.psyche_aggression, "shadow_risk": driver.shadow_risk}
         - Cache results to avoid repeated DB calls

       - `get_track_difficulty(self, track_id: str) -> float`:
         - Fetch track node from ontology
         - Return track.difficulty (0-1)

       - `get_veto_rules(self) -> List[VetoRule]`:
         - Return hardcoded veto rules (domain knowledge):
           - DNF → laps_led (DNF cannot lead laps)
           - DNF → fastest_laps (DNF cannot have fastest laps)
           - in_pit → position_changes (no position changes while pitting)
           - caution_segment → position_changes (no position changes during caution)
         - Add track-specific veto rules from ontology if defined

    3. **apply_veto_rules function**:
       - Signature: `def apply_veto_rules(structure: nx.DiGraph, veto_rules: List[VetoRule]) -> nx.DiGraph`
       - Input: CBN structure as NetworkX DiGraph (from pgmpy structure learning)
       - For each veto rule: remove edge if it exists in structure
       - Log each veto removal with reason
       - Return constrained structure

    4. **Type definitions**:
       - `CBNStructure = nx.DiGraph` (NetworkX directed graph)
       - `PriorDict = Dict[str, float]` (variable name -> prior value)

    Import OntologyDriver from apps.backend.app.ontology (use try/except ImportError with warning for standalone usage).

    DO NOT: Implement CBN learning here (that's in cbn.py). DO NOT: Encode race-flow logic (that's in state_space.py).
  </action>
  <verify>
    Run `python -c "from packages.axiomatic_sim.src.ontology_constraints import OntologyConstraints, VetoRule, apply_veto_rules; print('Constraints module imports successfully')"`
  </verify>
  <done>
    VetoRule dataclass defined with 3 fields, OntologyConstraints class has 4 methods, apply_veto_rules function accepts DiGraph and returns constrained DiGraph
  </done>
</task>

<task type="auto">
  <name>Implement Causal Bayesian Network with ontology-constrained structure learning</name>
  <files>packages/axiomatic-sim/src/cbn.py</files>
  <action>
    Create `packages/axiomatic-sim/src/cbn.py` with pgmpy-based CBN:

    1. **CausalBayesianNetwork class** wrapping pgmpy.BayesianNetwork:
       - `__init__(self, structure: nx.DiGraph, ontology_constraints: OntologyConstraints)`:
         - Store ontology_constraints reference
         - Initialize pgmpy BayesianNetwork with constrained structure
         - Validate structure is acyclic

       - `learn_parameters(self, data: pd.DataFrame, priors: Optional[Dict[str, float]] = None)`:
         - Use pgmpy.BayesianEstimator for parameter learning
         - If priors provided (from ontology), pass as pseudo_counts
         - Fit CPDs (Conditional Probability Distributions) for each node
         - Return self for method chaining

       - `sample_outcomes(self, n_samples: int, evidence: Optional[Dict[str, Any]] = None) -> pd.DataFrame`:
         - Use pgmpy.inference.VariableElimination for exact inference
         - Sample n_samples from joint distribution
         - If evidence provided (e.g., caution=True), condition on evidence
         - Return DataFrame with columns: driver_id, laps_led, fastest_laps, finish_position, incidents

       - `get_conditional_probability(self, target: str, evidence: Dict[str, Any]) -> float`:
         - Query P(target | evidence) using VariableElimination
         - Return probability value

    2. **learn_structure function**:
       - Signature: `def learn_structure(data: pd.DataFrame, ontology_constraints: OntologyConstraints) -> nx.DiGraph`
       - Use pgmpy.estimators.PC for structure learning (constraint-based)
       - Extract learned DAG (Directed Acyclic Graph)
       - Apply veto rules via apply_veto_rules()
       - Return constrained structure

    3. **create_cbn_variables function**:
       - Signature: `def create_cbn_variables(driver_ids: List[str]) -> List[str]`
       - Create CBN variable names for each driver:
         - "{driver_id}_skill" (latent, from ontology)
         - "{driver_id}_incident_prob" (probability of incident)
         - "{driver_id}_laps_led" (dominator outcome)
         - "{driver_id}_fastest_laps" (dominator outcome)
         - "{driver_id}_finish_position" (final position)
       - Return list of variable names

    4. **Hybrid parameterization helper**:
       - `def get_ontology_priors(ontology_constraints: OntologyConstraints, driver_ids: List[str]) -> Dict[str, float]`:
         - For each driver: fetch skill, aggression, shadow_risk from ontology
         - Return dict: "{driver_id}_skill": skill_value
         - Use as priors in BayesianEstimator

    Import pgmpy components:
    - `from pgmpy.models import BayesianNetwork`
    - `from pgmpy.estimators import PC, BayesianEstimator`
    - `from pgmpy.inference import VariableElimination`
    - `import networkx as nx`

    Import from ontology_constraints:
    - `from packages.axiomatic_sim.src.ontology_constraints import OntologyConstraints, apply_veto_rules`

    DO NOT: Implement scenario sampling (that's scenario generation, next plan). DO NOT: Use full DBN (simplified with latent factors per research).
  </action>
  <verify>
    Run `python -c "from packages.axiomatic_sim.src.cbn import CausalBayesianNetwork, learn_structure, create_cbn_variables; print('CBN module imports successfully')"` (may have pgmpy import error if not installed, that's OK for now)
  </verify>
  <done>
    CausalBayesianNetwork class wraps pgmpy.BayesianNetwork, learn_structure applies veto rules, create_cbn_variables generates variable names per driver, get_ontology_priors fetches priors from ontology
  </done>
</task>

<task type="auto">
  <name>Create property-based tests for ontology veto rules and CBN structure constraints</name>
  <files>packages/axiomatic-sim/tests/test_ontology_constraints.py</files>
  <action>
    Create `packages/axiomatic-sim/tests/test_ontology_constraints.py` with Hypothesis tests:

    1. **test_veto_rules_remove_impossible_edges**:
       - Given: DiGraph with edge ("DNF", "laps_led_after_incident")
       - When: Apply veto rules (DNF → laps_led forbidden)
       - Then: Edge removed from graph

    2. **test_veto_rules_preserve_valid_edges**:
       - Given: DiGraph with valid edge ("skill", "laps_led")
       - When: Apply veto rules
       - Then: Edge remains in graph

    3. **test_structure_remains_acyclic_after_veto**:
       - Given: DiGraph with cycle involving vetoed edge
       - When: Apply veto rules
       - Then: Result is acyclic (nx.is_directed_acyclic_graph returns True)

    4. **test_driver_priors_in_valid_range**:
       - Given: Mock OntologyDriver returning random priors (0-1)
       - When: Call get_driver_priors for random driver_id
       - Then: All returned priors in [0, 1]

    5. **test_ontology_constraints_cache_driver_priors**:
       - Given: OntologyConstraints instance
       - When: Call get_driver_priors twice for same driver
       - Then: Second call returns cached result (verify via mock call count)

    Use Hypothesis strategies:
    - `@given(st.lists(st.text(min_size=1, max_size=10), min_size=2, max_size=10))` for variable names
    - `@given(st.builds(nx.DiGraph))` for graph structures

    Mock OntologyDriver for tests (don't require actual Neo4j connection):
    - Use `unittest.mock.Mock` to return fixed priors
    - Test caching behavior with call counting

    Run with: `pytest packages/axiomatic-sim/tests/test_ontology_constraints.py -v`

    DO NOT: Test actual Neo4j queries (integration, not unit). DO NOT: Test CBN parameter learning (that's integration).
  </action>
  <verify>
    Run `pytest packages/axiomatic-sim/tests/test_ontology_constraints.py -v` and verify all 5 tests pass
  </verify>
  <done>
    All 5 property-based tests pass, veto rules remove forbidden edges, valid edges preserved, structure remains acyclic, priors validated, caching works
  </done>
</task>

</tasks>

<verification>
Run test suite: `pytest packages/axiomatic-sim/tests/test_ontology_constraints.py -v`

Verify imports: `python -c "from packages.axiomatic_sim.src.ontology_constraints import OntologyConstraints, apply_veto_rules; from packages.axiomatic_sim.src.cbn import CausalBayesianNetwork; print('All imports successful')"`

Check pgmpy integration: `python -c "import pgmpy; print(f'pgmpy version: {pgmpy.__version__}')"` (verify pgmpy is installed)
</verification>

<success_criteria>
1. OntologyConstraints class provides driver priors and veto rules
2. VetoRule dataclass represents forbidden CBN edges with reasons
3. apply_veto_rules removes forbidden edges from DiGraph
4. CausalBayesianNetwork wraps pgmpy with ontology-constrained structure
5. learn_structure applies veto rules before returning structure
6. Property-based tests validate veto enforcement and priors
</success_criteria>

<output>
After completion, create `.planning/phases/01-feasible-by-design-nascar-simulation-core/01-02-SUMMARY.md`
</output>
