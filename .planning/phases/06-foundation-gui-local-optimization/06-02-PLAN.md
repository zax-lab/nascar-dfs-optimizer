---
phase: 06-foundation-gui-local-optimization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/native_mac/persistence/database.py
  - apps/native_mac/persistence/models.py
  - apps/native_mac/persistence/session_manager.py
autonomous: true

must_haves:
  truths:
    - "Application creates SQLite database at first launch in ~/Library/Application Support/NASCAR DFS Optimizer/nascar_optimizer.db"
    - "Database schema includes races, lineups, optimization_configs, and app_state tables"
    - "SessionManager can save and restore window geometry (width, height, x, y)"
    - "SessionManager can save and restore last viewed race"
    - "Database connections use context managers for automatic cleanup"
  artifacts:
    - path: "apps/native_mac/persistence/database.py"
      provides: "DatabaseManager class with connection management"
      min_lines: 60
    - path: "apps/native_mac/persistence/models.py"
      provides: "SQLAlchemy ORM models for races, lineups, configs"
      contains: "class Race"
    - path: "apps/native_mac/persistence/session_manager.py"
      provides: "SessionManager for saving/restoring app state"
      contains: "save_window_geometry"
  key_links:
    - from: "apps/native_mac/persistence/database.py"
      to: "sqlite3"
      via: "Python built-in sqlite3 module"
      pattern: "import sqlite3"
    - from: "apps/native_mac/persistence/session_manager.py"
      to: "apps/native_mac/persistence/database.py"
      via: "DatabaseManager dependency"
      pattern: "from.*database import DatabaseManager"
---

## Objective

Create the SQLite persistence layer with database schema, ORM models, and session management for saving application state (window geometry, last race, lineups). This enables fast launch, offline operation, and session restore functionality.

**Purpose:** Desktop applications must persist user data and session state across launches. SQLite provides zero-config local storage without external dependencies. Session persistence is a core macOS app expectation.

**Output:** Working persistence layer with database schema, session state management, and data models for races, lineups, and configurations.

## Context

@/Users/zax/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zax/.claude/get-shit-done/templates/summary.md

@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-foundation-gui-local-optimization/06-RESEARCH.md

## Tasks

<task type="auto">
  <name>Create database schema and connection manager</name>
  <files>apps/native_mac/persistence/database.py</files>
  <action>
Create the database infrastructure with SQLite connection management:

1. Create `apps/native_mac/persistence/` directory with `__init__.py`

2. Create `database.py` with DatabaseManager class:
   - Database path: ~/Library/Application Support/NASCAR DFS Optimizer/nascar_optimizer.db
   - Context manager for connection handling (automatic commit/rollback)
   - Schema initialization with CREATE TABLE IF NOT EXISTS

3. Define schema with tables:
   - `races`: id, track_name, race_date, created_at
   - `lineups`: id, race_id (FK), lineup_data (JSON), created_at
   - `optimization_configs`: id, name, config_data (JSON), created_at
   - `app_state`: key (PK), value (JSON), updated_at

4. Use sqlite3.row_factory for column name access
5. Implement methods:
   - get_connection() context manager
   - _init_schema() for table creation
   - save_lineup(race_id, lineup_data) -> int
   - load_lineups(race_id=None) -> list

Follow research pattern from 06-RESEARCH.md > SQLite Persistence with Context Manager.
  </action>
  <verify>
File exists at `apps/native_mac/persistence/database.py`
DatabaseManager class has get_connection context manager
_init_schema creates all 4 tables
save_lineup and load_lineups methods exist
Database path uses macOS Application Support directory
  </verify>
  <done>
Database schema defined and initialized
Connection manager with context pattern working
Database created at first launch in proper macOS location
  </done>
</task>

<task type="auto">
  <name>Create ORM models for type-safe data access</name>
  <files>apps/native_mac/persistence/models.py</files>
  <action>
Create SQLAlchemy-style models for type-safe database operations (using raw sqlite3 for simplicity, but with model-like structure):

1. Create `models.py` with dataclass models:
   - Race: id, track_name, race_date, created_at
   - Lineup: id, race_id, lineup_data (dict), created_at
   - OptimizationConfig: id, name, config_data (dict), created_at
   - AppState: key, value (dict), updated_at

2. Use Python dataclasses for type hints and validation:
```python
from dataclasses import dataclass
from typing import Dict, Any
from datetime import datetime

@dataclass
class Race:
    id: int
    track_name: str
    race_date: str
    created_at: datetime
```

3. Add helper methods:
   - Race.to_dict() for database insertion
   - Race.from_row(row) for constructing from sqlite3 rows
   - Similar patterns for Lineup, OptimizationConfig, AppState

4. Add validation in model constructors:
   - Required fields validation
   - Type coercion for dates and JSON data
  </action>
  <verify>
models.py defines Race, Lineup, OptimizationConfig, AppState dataclasses
Each model has to_dict and from_row class methods
Models use type hints for all fields
Validation logic in constructors
  </verify>
  <done>
Type-safe data models created
Helper methods for database serialization working
Models can be constructed from database rows
  </done>
</task>

<task type="auto">
  <name>Create session manager for window geometry and state persistence</name>
  <files>apps/native_mac/persistence/session_manager.py</files>
  <action>
Create SessionManager class for saving/restoring application state:

1. Create `session_manager.py` with SessionManager class:
   - Depends on DatabaseManager for storage
   - Saves window geometry (width, height, x, y, maximized state)
   - Saves last viewed race
   - Saves and restores arbitrary app state via key-value storage

2. Implement methods:
   - save_window_geometry(window) -> saves QMainWindow geometry
   - load_window_geometry(window) -> restores QMainWindow geometry
   - save_last_race(race_id, track_name) -> saves last race
   - load_last_race() -> returns dict with race data
   - save_state(key, value) -> generic key-value storage
   - load_state(key, default=None) -> retrieves value

3. Window geometry handling:
   - Use window.geometry() to get QRect
   - Use window.saveGeometry() for binary state (includes maximized)
   - Store as base64-encoded bytes in app_state table
   - Restore with window.restoreGeometry()

4. Follow research pattern from 06-RESEARCH.md > SQLite Session Persistence.
  </action>
  <verify>
SessionManager has save_window_geometry and load_window_geometry methods
Window geometry saved as base64-encoded bytes in app_state table
load_window_geometry restores position and size
save_last_race and load_last_race methods working
Generic save_state/load_state methods working
  </verify>
  <done>
Session state can be saved and restored
Window geometry persists across app launches
Last viewed race can be restored on startup
Generic key-value storage working for app state
  </done>
</task>

## Verification

After completing all tasks, verify the persistence layer:

1. Run Python and import DatabaseManager - database created in Application Support
2. Check `~/Library/Application Support/NASCAR DFS Optimizer/nascar_optimizer.db` exists
3. Use sqlite3 to inspect schema - all 4 tables present
4. Test session save/restore:
```python
from apps.native_mac.persistence.session_manager import SessionManager
sm = SessionManager()
sm.save_window_geometry(test_window)
sm.load_window_geometry(test_window)  # Restores geometry
```
5. Verify context manager closes connections properly

## Success Criteria

- [ ] Database created at first launch in macOS Application Support directory
- [ ] All 4 tables exist in database schema
- [ ] SessionManager can save and restore window geometry
- [ ] SessionManager can save and load last viewed race
- [ ] Database connections use context managers for automatic cleanup
- [ ] Models provide type-safe data access with validation

## Output

After completion, create `.planning/phases/06-foundation-gui-local-optimization/06-02-SUMMARY.md`
