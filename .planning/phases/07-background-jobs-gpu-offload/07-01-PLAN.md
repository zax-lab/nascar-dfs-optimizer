---
phase: 07-background-jobs-gpu-offload
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [
  apps/native_mac/jobs/job_manager.py,
  apps/native_mac/jobs/__init__.py,
  apps/native_mac/gui/menubar_extra.py,
  apps/native_mac/gui/main_window.py,
  apps/native_mac/gui/views/optimization_tab.py,
  apps/native_mac/persistence/models.py,
  apps/native_mac/persistence/database.py,
  apps/native_mac/dock_handler.py
]
autonomous: true

must_haves:
  truths:
    - User sees Dock badge showing number of running/queued jobs
    - User submits optimization job and sees it queued (not blocking UI)
    - Multiple optimization jobs run concurrently (up to CPU count)
    - User sees menubar icon with quick status of running jobs
    - Jobs persist in SQLite and survive app restart
    - User can view all jobs in a jobs tab with status (queued/running/completed/failed)
  artifacts:
    - path: apps/native_mac/jobs/job_manager.py
      provides: JobManager class with queue, executor, and status tracking
      min_lines: 150
    - path: apps/native_mac/gui/menubar_extra.py
      provides: SystemTrayIcon with job status menu
      min_lines: 80
    - path: apps/native_mac/persistence/models.py
      provides: Job model for SQLite persistence
      min_lines: 30
  key_links:
    - from: apps/native_mac/gui/views/optimization_tab.py
      to: apps/native_mac/jobs/job_manager.py
      via: submit_job() signal/slot connection
      pattern: job_manager.submit_job\(optimization_config\)
    - from: apps/native_mac/jobs/job_manager.py
      to: apps/native_mac/dock_handler.py
      via: dock badge update on job status change
      pattern: dock_handler.set_badge_count\(count\)
    - from: apps/native_mac/gui/menubar_extra.py
      to: apps/native_mac/jobs/job_manager.py
      via: polling or signal connection for status updates
      pattern: job_manager.get_running_jobs_count\(\)
---

<objective>
Create background job infrastructure for concurrent optimization jobs with Dock badge progress and menubar status indicator.

Purpose: Enable workflow acceleration by allowing multiple optimizations to run in parallel while the user continues working in the main window.

Output: JobManager with thread pool executor, SQLite persistence, Dock badge updates, and system tray menubar extra.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-foundation-gui-local-optimization/06-10-SUMMARY.md

**Existing infrastructure to leverage:**

From Phase 6 (Foundation GUI):
- OptimizationEngine in apps/native_mac/optimization/engine.py - Currently runs synchronously via QThread worker
- SessionManager in apps/native_mac/persistence/session_manager.py - Pattern for state persistence
- DatabaseManager in apps/native_mac/persistence/database.py - SQLite connection management
- DockIconHandler in apps/native_mac/dock_handler.py - Dock bounce on completion (extend for badge)
- MainWindow with tabbed interface in apps/native_mac/gui/main_window.py - Add Jobs tab

**Key patterns established:**
- Signal/slot mechanism for async updates (progress_worker.py pattern)
- QThread for non-blocking background work
- SQLite persistence with context managers
- Qt Model/View architecture for tables

**Requirements to satisfy:**
- GUI-07: Menubar extra for quick status and job progress
- OPT-06: Background job queue (run multiple optimizations concurrently)
- SYS-04: Dock badge for job status (progress pie icon, completion count)

**Technical constraints:**
- Use concurrent.futures.ThreadPoolExecutor for job concurrency (CPU-bound JAX work)
- SQLite for job persistence (already have DatabaseManager)
- PySide6 for all UI components (consistent with Phase 6)
- Job states: queued, running, completed, failed, cancelled
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JobManager with thread pool and SQLite persistence</name>
  <files>apps/native_mac/jobs/job_manager.py, apps/native_mac/jobs/__init__.py, apps/native_mac/persistence/models.py, apps/native_mac/persistence/database.py</files>
  <action>
Create JobManager class that manages concurrent optimization jobs:

1. In apps/native_mac/persistence/models.py:
   - Add Job dataclass with fields: id, name, status, config_json, result_json, created_at, started_at, completed_at, error_message
   - Status enum: QUEUED, RUNNING, COMPLETED, FAILED, CANCELLED

2. In apps/native_mac/persistence/database.py:
   - Add create_jobs_table() method with schema for Job model
   - Add job CRUD methods: insert_job(), update_job(), get_job(), list_jobs(), delete_old_jobs()
   - Call create_jobs_table() in init_database()

3. Create apps/native_mac/jobs/__init__.py:
   - Export JobManager, JobStatus

4. Create apps/native_mac/jobs/job_manager.py:
   - Import concurrent.futures.ThreadPoolExecutor
   - Class JobManager(QObject) with signals: job_started, job_progress, job_completed, job_failed, job_cancelled
   - __init__(max_workers=None) - default to CPU count
   - submit_job(config: dict) -> job_id: str - queues job, returns UUID
   - cancel_job(job_id: str) -> bool - attempts cancellation
   - get_job_status(job_id: str) -> JobStatus
   - get_running_jobs() -> List[Job]
   - get_queued_jobs() -> List[Job]
   - get_recent_jobs(limit: int = 50) -> List[Job]
   - _execute_job(job_id: str, config: dict) - internal worker method that:
     * Updates job status to RUNNING in SQLite
     * Runs optimization using OptimizationEngine pattern (but as function, not QThread)
     * Emits progress updates via callback
     * Updates job with result or error
   - shutdown() - cancel pending and wait for running jobs (call on app quit)

5. Key design decisions:
   - Use ThreadPoolExecutor for true parallelism (JAX releases GIL, so threads work for CPU-bound)
   - SQLite persistence allows job history and resume after crash
   - JSON serialization for config and results
   - Progress callback updates job record periodically (every 10% or 5 seconds)

6. Do NOT use multiprocessing - JAX already parallelizes via thread pool
7. Do NOT create circular imports - JobManager depends on database, not GUI
  </action>
  <verify>
python -c "
from apps.native_mac.jobs.job_manager import JobManager
from apps.native_mac.persistence.database import DatabaseManager
db = DatabaseManager()
jm = JobManager(max_workers=2)
assert jm.executor._max_workers == 2
print('JobManager created successfully')
jm.shutdown()
"
  </verify>
  <done>JobManager class exists with thread pool, SQLite persistence, and signals for job lifecycle events</done>
</task>

<task type="auto">
  <name>Task 2: Create Jobs tab and integrate with Optimization tab</name>
  <files>apps/native_mac/gui/views/jobs_tab.py, apps/native_mac/gui/main_window.py, apps/native_mac/gui/views/optimization_tab.py</files>
  <action>
Create Jobs tab UI and modify Optimization tab to submit to queue:

1. Create apps/native_mac/gui/views/jobs_tab.py:
   - Class JobsTab(QWidget) with:
   - QTableView for job list showing: Name, Status, Created, Duration, Progress
   - QAbstractTableModel subclass JobTableModel
   - Status column shows colored badges (queued=gray, running=blue, completed=green, failed=red)
   - Context menu with: View Details, Cancel Job, Delete Job, Re-run Job
   - Double-click to view job details (config + result in dialog)
   - Toolbar with: Refresh, Clear Completed, Export History
   - Auto-refresh every 2 seconds for running jobs

2. Modify apps/native_mac/gui/main_window.py:
   - Add jobs_tab import
   - In create_tabs(), add self.jobs_tab = JobsTab(self.job_manager)
   - Add "Jobs" tab to QTabWidget after Optimization tab
   - Store job_manager reference (passed from main.py)
   - Update window title to show running job count: "NASCAR DFS Optimizer (2 jobs running)"

3. Modify apps/native_mac/gui/views/optimization_tab.py:
   - Replace direct optimization execution with job submission
   - In on_run_optimization(): create config dict, call job_manager.submit_job(config)
   - Show confirmation: "Optimization 'Talladega GPP' queued (Job #abc123)"
   - Add "Submit to Queue" button alongside "Run Optimization" (or replace it)
   - Keep progress dialog optional (for users who want to watch one job)
   - On job completion signal, auto-switch to Jobs tab or Lineups tab

4. Key integration points:
   - JobManager emits job_completed signal -> JobsTab refreshes
   - JobManager emits job_progress signal -> JobsTab updates progress column
   - Optimization tab creates config dict with all constraint values
   - Config includes: race_id, constraints, lineup_count, iterations, job_name

5. Do NOT block UI when submitting - job submission is instant (just adds to queue)
6. Do NOT remove existing optimization code - keep it for single-job mode if needed
  </action>
  <verify>
python -c "
from apps.native_mac.gui.views.jobs_tab import JobsTab
from PySide6.QtWidgets import QApplication
app = QApplication([])
tab = JobsTab(None)
assert tab is not None
print('JobsTab created successfully')
"
  </verify>
  <done>Jobs tab displays job list with status, Optimization tab submits to queue instead of blocking, integration complete</done>
</task>

<task type="auto">
  <name>Task 3: Implement Dock badge and menubar extra</name>
  <files>apps/native_mac/dock_handler.py, apps/native_mac/gui/menubar_extra.py, apps/native_mac/main.py</files>
  <action>
Add Dock badge for job count and system tray menubar extra:

1. Modify apps/native_mac/dock_handler.py:
   - Add set_badge_count(count: int) method:
     * Use NSApp.setApplicationIconImage_ with badge overlay
     * Or use NSApp.dockTile().setBadgeLabel_(str(count)) if count > 0
     * Clear badge if count is 0
   - Add set_badge_progress(percent: int) for pie-chart style (optional enhancement)
   - Add bounce_on_completion() method (already exists, enhance to trigger on any job complete)

2. Create apps/native_mac/gui/menubar_extra.py:
   - Class SystemTrayIcon(QSystemTrayIcon):
   - __init__(job_manager): store reference, create menu
   - create_menu(): QMenu with:
     * "NASCAR DFS Optimizer" (disabled header)
     * Separator
     * "Running: N jobs" (disabled, dynamic)
     * "Recent Jobs" submenu (last 5 completed)
     * Separator
     * "Show Main Window" - raises main window
     * "Preferences" - opens settings
     * Separator
     * "Quit" - quits app
   - on_activated(reason): show menu on left-click, toggle window on double-click
   - update_menu(): refresh job counts and recent jobs
   - show_notification(title, message): native macOS notification

3. Modify apps/native_mac/main.py:
   - In main(), after creating job_manager:
     * Connect job_manager signals to dock badge updates
     * dock_handler.set_badge_count(len(job_manager.get_running_jobs()))
   - Create SystemTrayIcon instance
   - Show tray icon: tray_icon.show()
   - Connect job_manager.job_started/completed/failed to tray icon update
   - On job completion: tray_icon.show_notification("Optimization Complete", f"Job '{job_name}' finished with status {status}")
   - Add hide/show main window toggle in tray menu

4. Key behaviors:
   - Dock badge shows total (queued + running) count
   - Badge clears when all jobs done
   - Menubar icon visible even when main window closed
   - Menubar shows quick job status without opening main window
   - Clicking notification brings app to foreground and switches to Jobs tab

5. Do NOT show tray icon if running in CI/test mode (check environment)
6. Do NOT duplicate notifications - if app is active, maybe skip notification
  </action>
  <verify>
python -c "
from apps.native_mac.gui.menubar_extra import SystemTrayIcon
from PySide6.QtWidgets import QApplication
app = QApplication([])
tray = SystemTrayIcon(None)
assert tray is not None
print('SystemTrayIcon created successfully')
"
  </verify>
  <done>Dock badge updates with job count, menubar extra shows status menu, notifications appear on job completion</done>
</task>

</tasks>

<verification>
1. Submit 3 optimization jobs quickly - all should queue and run concurrently
2. Dock badge shows "3" while running, clears to "0" when done
3. Menubar icon shows running count in menu
4. Close main window - menubar icon remains, can reopen window from menu
5. Quit and reopen app - job history persists in Jobs tab
6. Job states progress: queued → running → completed (or failed)
7. Can cancel queued job, cannot cancel running job (or sends cancellation request)
</verification>

<success_criteria>
- JobManager manages concurrent execution with ThreadPoolExecutor
- SQLite persists job history with full config and results
- Jobs tab shows sortable/filterable job list with status badges
- Dock badge displays running/queued job count
- Menubar extra provides quick status without opening main window
- Optimization submits to queue without blocking UI
- Notifications appear on job completion with "View" action
</success_criteria>

<output>
After completion, create `.planning/phases/07-background-jobs-gpu-offload/07-01-SUMMARY.md`
</output>
