---
phase: 08-workflow-accelerators
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/native_mac/persistence/preset_manager.py
  - apps/native_mac/gui/views/presets_tab.py
  - apps/native_mac/persistence/database.py
autonomous: true

must_haves:
  truths:
    - "User can save constraint presets with a name and description"
    - "User can load saved presets from a library view"
    - "Presets are scoped as global (all races) or race-specific (filtered by race type/track)"
    - "Recent presets appear in quick-access list for fast re-application"
    - "Presets persist across app restarts in SQLite"
  artifacts:
    - path: "apps/native_mac/persistence/preset_manager.py"
      provides: "PresetManager class with save/load/list operations"
      min_lines: 150
    - path: "apps/native_mac/gui/views/presets_tab.py"
      provides: "PresetsTab UI for browsing and managing presets"
      min_lines: 200
    - path: "apps/native_mac/persistence/database.py"
      provides: "constraint_presets and recent_presets tables"
      contains: "CREATE TABLE constraint_presets"
  key_links:
    - from: "PresetsTab"
      to: "PresetManager"
      via: "load_preset(), save_preset(), get_presets_for_race()"
    - from: "ConstraintPanel"
      to: "PresetManager"
      via: "set_constraints(), get_constraints() integration"
    - from: "PresetManager"
      to: "SQLite database"
      via: "SQLite JSON1 extension for config storage"
---

<objective>
Create a comprehensive constraint preset system allowing users to save, load, and manage constraint configurations with race-specific and global scoping, plus quick-access recent presets.

Purpose: Power users need to quickly apply constraint sets for different race types (short tracks vs superspeedways). Without presets, users manually reconfigure constraints for every race.

Output: PresetManager class, PresetsTab UI, SQLite schema for presets, integration with ConstraintPanel
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-workflow-accelerators/08-CONTEXT.md
@.planning/phases/08-workflow-accelerators/08-RESEARCH.md
@apps/native_mac/gui/widgets/constraint_panel.py
@apps/native_mac/persistence/database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PresetManager with SQLite storage</name>
  <files>apps/native_mac/persistence/preset_manager.py</files>
  <action>
    Create PresetManager class that handles constraint preset persistence using SQLite JSON columns.

    Schema (match research pattern):
    - constraint_presets: id, name, description, is_global (bool), race_type, track_name, config_json (JSON), created_at, updated_at, usage_count
    - recent_presets: id, preset_id (FK), applied_at

    Implement methods:
    - save_preset(name, config, is_global=False, race_type=None, track_name=None, description="") -> int (returns preset_id)
    - load_preset(preset_id: int) -> Dict (constraint config)
    - delete_preset(preset_id: int) -> None
    - get_presets_for_race(race_type: str, track_name: str) -> List[Dict] (returns global + race-specific presets, sorted by is_global DESC, name ASC)
    - get_recent_presets(limit: int = 5) -> List[Dict] (most recently applied presets)
    - record_preset_usage(preset_id: int) -> None (adds to recent_presets, increments usage_count)
    - export_preset_to_json(preset_id: int, filepath: str) -> None (for sharing presets)
    - import_preset_from_json(filepath: str) -> int (returns new preset_id)

    Include version field in JSON config for future migrations.

    Use existing database connection pattern from DatabaseManager (context manager for connections).
  </action>
  <verify>
    python -c "from apps.native_mac.persistence.preset_manager import PresetManager; pm = PresetManager('test.db'); pid = pm.save_preset('Test', {'salary_cap': 50000}, is_global=True); print(f'Created preset {pid}'); loaded = pm.load_preset(pid); assert loaded['salary_cap'] == 50000; print('OK')"
  </verify>
  <done>PresetManager class exists with all CRUD methods, SQLite tables created, save/load/verify works</done>
</task>

<task type="auto">
  <name>Task 2: Create PresetsTab UI for preset library</name>
  <files>apps/native_mac/gui/views/presets_tab.py</files>
  <action>
    Create PresetsTab widget for browsing, loading, and managing constraint presets.

    UI structure (follow Qt Model/View patterns from Phase 6):
    - Split view: Left = preset list/filter, Right = preset details/preview
    - Preset list: QTableView with QAbstractTableModel showing name, scope (global/race-specific), race type, track, usage count, last used
    - Filter controls: Race type dropdown, Track dropdown, Global vs Race-specific checkbox, Search by name
    - Preset details: Name, description, constraint preview (salary cap, ownership limits, stacking rules as read-only text)
    - Action buttons: Load Preset, Delete Preset, Export to JSON, Import from JSON
    - Quick-access recent presets: Horizontal row of chips/buttons at top for last 5 applied presets

    Signals:
    - preset_loaded(config: Dict) - emitted when user clicks Load Preset
    - preset_selected(preset_id: int) - emitted when user selects a preset (for preview)

    Connect to PresetManager for data operations.
    Follow styling patterns from other tabs (QGroupBox sections, consistent spacing).
  </action>
  <verify>
    python -c "from PySide6.QtWidgets import QApplication; app = QApplication([]); from apps.native_mac.gui.views.presets_tab import PresetsTab; tab = PresetsTab(None); print(f'PresetsTab created: {tab}'); print('OK')"
  </verify>
  <done>PresetsTab UI exists with list view, filters, details panel, recent presets row, and action buttons</done>
</task>

<task type="auto">
  <name>Task 3: Integrate PresetManager with ConstraintPanel and MainWindow</name>
  <files>
    apps/native_mac/gui/widgets/constraint_panel.py
    apps/native_mac/persistence/database.py
    apps/native_mac/main.py
  </files>
  <action>
    Integrate preset system into existing UI components.

    In constraint_panel.py:
    - Replace stub _load_presets() with real implementation using PresetManager
    - Replace stub _on_load_preset() to use PresetManager.load_preset() + set_constraints()
    - Replace stub _on_save_preset() to use PresetManager.save_preset()
    - Add signal: preset_applied(config: Dict) - emitted when preset is loaded

    In database.py:
    - Add schema migration for constraint_presets and recent_presets tables
    - Ensure tables are created on DatabaseManager initialization

    In main.py:
    - Create PresetManager instance alongside DatabaseManager
    - Pass PresetManager to ConstraintPanel and PresetsTab via constructor injection
    - Wire preset_loaded signal from PresetsTab to ConstraintPanel.set_constraints()
    - Add PresetsTab to QTabWidget (new tab between "Optimization" and "Jobs")

    Verify preset flow works end-to-end:
    1. Save preset from ConstraintPanel
    2. See it appear in PresetsTab
    3. Load preset from PresetsTab
    4. See constraints update in ConstraintPanel
  </action>
  <verify>
    python -c "
    import sys
    sys.path.insert(0, '.')
    from apps.native_mac.persistence.preset_manager import PresetManager
    from apps.native_mac.gui.widgets.constraint_panel import ConstraintPanel
    from PySide6.QtWidgets import QApplication
    app = QApplication.instance() or QApplication([])
    pm = PresetManager('test_integration.db')
    panel = ConstraintPanel(pm)
    print(f'ConstraintPanel with PresetManager: {panel}')
    print('Integration OK')
    "
  </verify>
  <done>ConstraintPanel uses PresetManager for real preset save/load, PresetsTab integrated into MainWindow, end-to-end flow verified</done>
</task>

</tasks>

<verification>
- [ ] PresetManager can save and load presets with JSON configs
- [ ] Preset scoping (global vs race-specific) filters correctly
- [ ] Recent presets track and display in quick-access row
- [ ] PresetsTab UI allows browsing, filtering, loading, deleting presets
- [ ] ConstraintPanel preset buttons work end-to-end
- [ ] Presets persist across app restarts
</verification>

<success_criteria>
1. User can save a constraint preset with name and see it in the Presets library
2. User can filter presets by race type and track
3. User can load a preset and see constraints update in ConstraintPanel
4. Recently used presets appear in quick-access row for one-click reapplication
5. Presets survive app restart (stored in SQLite)
</success_criteria>

<output>
After completion, create `.planning/phases/08-workflow-accelerators/08-01-SUMMARY.md`
</output>
