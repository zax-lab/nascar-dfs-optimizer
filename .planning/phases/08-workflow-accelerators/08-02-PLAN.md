---
phase: 08-workflow-accelerators
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/native_mac/undo/undo_manager.py
  - apps/native_mac/undo/commands.py
  - apps/native_mac/gui/views/optimization_tab.py
  - apps/native_mac/gui/views/lineups_tab.py
autonomous: true

must_haves:
  truths:
    - "User can undo any action (constraint change, lineup edit, preset load) with CMD+Z"
    - "User can redo undone actions with CMD+Shift+Z"
    - "Undo stack is unlimited depth (no limit on history)"
    - "Per-race undo context isolates changes to specific races"
    - "Global undo stack tracks app-level actions (tab switches, imports, exports)"
  artifacts:
    - path: "apps/native_mac/undo/undo_manager.py"
      provides: "UndoManager with per-race and global QUndoStack instances"
      min_lines: 150
    - path: "apps/native_mac/undo/commands.py"
      provides: "QUndoCommand subclasses for all undoable actions"
      min_lines: 200
    - path: "apps/native_mac/main.py"
      provides: "Undo/redo menu actions with QKeySequence shortcuts"
      contains: "undo_action.setShortcut(QKeySequence.Undo)"
  key_links:
    - from: "OptimizationTab"
      to: "UndoManager"
      via: "push() when constraints change"
    - from: "LineupsTab"
      to: "UndoManager"
      via: "push() when lineup is edited"
    - from: "UndoManager"
      to: "QUndoStack"
      via: "setUndoLimit(0) for unlimited depth"
---

<objective>
Implement comprehensive undo/redo system with unlimited depth, supporting both per-race and global undo contexts for all user actions.

Purpose: Power users need confidence to experiment. Without undo, a mistaken constraint change or lineup edit forces manual reversion. Unlimited undo enables exploration without risk.

Output: UndoManager class, QUndoCommand subclasses for all actions, integration with OptimizationTab and LineupsTab, Edit menu with standard shortcuts
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-workflow-accelerators/08-CONTEXT.md
@.planning/phases/08-workflow-accelerators/08-RESEARCH.md
@apps/native_mac/gui/views/optimization_tab.py
@apps/native_mac/gui/views/lineups_tab.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UndoManager with per-race and global stacks</name>
  <files>apps/native_mac/undo/undo_manager.py</files>
  <action>
    Create UndoManager class that manages multiple QUndoStack instances for per-race and global undo contexts.

    Implementation (follow research Pattern 4):
    - global_stack: QUndoStack with setUndoLimit(0) for unlimited depth
    - race_stacks: Dict[str, QUndoStack] mapping race_id to per-race stack
    - current_race_id: str tracking which race is active

    Methods:
    - set_current_race(race_id: str) -> None: Switch active race context, creating new stack if needed
    - push(command: QUndoCommand, scope: str = "auto") -> None: Push command to appropriate stack(s)
      - scope="race": Push to current race stack only
      - scope="global": Push to global stack only  
      - scope="auto": Push to both (race-specific actions to race, global actions to global)
    - can_undo(scope: str = "auto") -> bool: Check if undo available
    - can_redo(scope: str = "auto") -> bool: Check if redo available
    - undo(scope: str = "auto") -> None: Perform undo on appropriate stack
    - redo(scope: str = "auto") -> None: Perform redo on appropriate stack
    - get_undo_text(scope: str = "auto") -> str: Get description of next undoable action
    - get_redo_text(scope: str = "auto") -> str: Get description of next redoable action
    - create_undo_action(parent, text: str = "&Undo") -> QAction: Returns QAction with QKeySequence.Undo
    - create_redo_action(parent, text: str = "&Redo") -> QAction: Returns QAction with QKeySequence.Redo

    Follow Qt command pattern - push() automatically calls redo(), so commands should NOT call redo() in their constructors.

    Signal:
    - can_undo_changed(bool): Emitted when undo availability changes
    - can_redo_changed(bool): Emitted when redo availability changes
  </action>
  <verify>
    python -c "
    from PySide6.QtWidgets import QApplication
    from PySide6.QtGui import QUndoCommand
    app = QApplication.instance() or QApplication([])
    from apps.native_mac.undo.undo_manager import UndoManager
    um = UndoManager()
    um.set_current_race('race1')
    class TestCmd(QUndoCommand):
        def __init__(self):
            super().__init__('Test')
        def undo(self): print('undo')
        def redo(self): print('redo')
    um.push(TestCmd())
    assert um.can_undo()
    um.undo()
    assert um.can_redo()
    print('UndoManager OK')
    "
  </verify>
  <done>UndoManager class exists with per-race and global stacks, unlimited undo depth, push/undo/redo methods working</done>
</task>

<task type="auto">
  <name>Task 2: Create QUndoCommand subclasses for all actions</name>
  <files>apps/native_mac/undo/commands.py</files>
  <action>
    Create QUndoCommand subclasses for every undoable action in the app.

    Commands needed:
    1. SetConstraintCommand: For constraint panel changes (single constraint)
       - __init__(model, constraint_id, old_value, new_value)
       - undo(): model.set_constraint(constraint_id, old_value)
       - redo(): model.set_constraint(constraint_id, new_value)
       - mergeWith(): Merge consecutive changes to same constraint (Pattern 3 from research)

    2. LoadPresetCommand: For loading constraint presets (macro command)
       - __init__(model, old_config: Dict, new_config: Dict)
       - undo(): Restore all constraints to old_config
       - redo(): Apply all constraints from new_config

    3. EditLineupCommand: For lineup edits (add/remove/replace driver)
       - __init__(lineup_model, lineup_index, old_lineup: List, new_lineup: List)
       - undo(): Restore old lineup
       - redo(): Apply new lineup

    4. SwitchTabCommand: For tab navigation (global scope)
       - __init__(tab_widget, old_index: int, new_index: int)
       - undo(): tab_widget.setCurrentIndex(old_index)
       - redo(): tab_widget.setCurrentIndex(new_index)

    5. ImportDataCommand: For CSV imports (global scope)
       - __init__(data_controller, old_data: Any, new_data: Any)
       - undo(): Restore old data state
       - redo(): Apply new data

    6. SetLineupCountCommand: For changing number of lineups to generate
       - __init__(spin_box, old_value: int, new_value: int)
       - undo/redo with merge support

    Each command must:
    - Call super().__init__(descriptive_text) for menu display
    - Store minimal state (IDs, values) not full objects (avoid memory bloat)
    - Implement id() and mergeWith() for high-frequency actions (sliders, spin boxes)

    Include COMMAND_IDS enum for unique command identification.
  </action>
  <verify>
    python -c "
    from PySide6.QtWidgets import QApplication
    app = QApplication.instance() or QApplication([])
    from apps.native_mac.undo.commands import SetConstraintCommand, LoadPresetCommand, EditLineupCommand
    print('Commands imported successfully')
    # Test command creation
    cmd = SetConstraintCommand(None, 'salary_cap', 50000, 55000)
    print(f'Command text: {cmd.text()}')
    print('Commands OK')
    "
  </verify>
  <done>All command classes exist with proper undo/redo implementations, merge support for high-frequency actions</done>
</task>

<task type="auto">
  <name>Task 3: Integrate UndoManager into MainWindow and wire all actions</name>
  <files>
    apps/native_mac/main.py
    apps/native_mac/gui/views/optimization_tab.py
    apps/native_mac/gui/views/lineups_tab.py
  </files>
  <action>
    Integrate UndoManager throughout the application.

    In main.py:
    - Create UndoManager instance in MainWindow.__init__()
    - Add Edit menu with Undo and Redo actions (use createUndoAction/createRedoAction from UndoManager)
    - Connect CMD+Z and CMD+Shift+Z (automatic via QKeySequence.Undo/Redo)
    - Connect tab_changed signal to push SwitchTabCommand
    - Pass UndoManager to all tabs via set_undo_manager() or constructor

    In optimization_tab.py:
    - Add set_undo_manager(undo_manager) method
    - On constraint change: Create SetConstraintCommand and push to undo_manager (scope="race")
    - On preset load: Create LoadPresetCommand and push (scope="race")
    - On lineup count change: Create SetLineupCountCommand and push
    - Pass undo_manager to ConstraintPanel

    In lineups_tab.py:
    - Add set_undo_manager(undo_manager) method
    - On lineup edit: Create EditLineupCommand and push (scope="race")
    - On lineup delete: Push command

    In constraint_panel.py:
    - Connect all input changes to create and push SetConstraintCommand
    - Use mergeWith() to combine rapid slider/spinbox changes

    Add status bar indicator showing undo stack depth (optional but helpful).

    Test the full flow:
    1. Change salary cap to 55000
    2. Change max ownership to 60%
    3. Press CMD+Z → max ownership reverts
    4. Press CMD+Z → salary cap reverts
    5. Press CMD+Shift+Z → salary cap returns to 55000
  </action>
  <verify>
    python -c "
    from PySide6.QtWidgets import QApplication
    app = QApplication.instance() or QApplication([])
    from apps.native_mac.undo.undo_manager import UndoManager
    from apps.native_mac.undo.commands import SetConstraintCommand
    um = UndoManager()
    um.set_current_race('test_race')
    # Simulate constraint changes
    for i in range(3):
        cmd = SetConstraintCommand(None, f'c{i}', 0, i)
        um.push(cmd)
    assert um.can_undo()
    um.undo()
    assert um.get_undo_text() == 'Set c1'
    um.undo()
    assert um.get_undo_text() == 'Set c0'
    print('Integration test OK')
    "
  </verify>
  <done>UndoManager integrated in MainWindow, Edit menu with CMD+Z/Shift+Z, all tabs push commands on user actions</done>
</task>

</tasks>

<verification>
- [ ] UndoManager creates per-race and global stacks with unlimited depth
- [ ] All command classes implement undo/redo correctly
- [ ] CMD+Z triggers undo, CMD+Shift+Z triggers redo
- [ ] Constraint changes are undoable with merge support for rapid changes
- [ ] Preset loads are undoable (restores previous constraints)
- [ ] Tab switches are undoable
- [ ] Edit menu shows undo/redo with action descriptions
</verification>

<success_criteria>
1. User changes a constraint value and presses CMD+Z to undo it
2. User loads a preset and presses CMD+Z to revert to previous constraints
3. User rapidly adjusts a slider and single undo reverts all rapid changes (merge)
4. Edit menu displays "Undo Set Salary Cap" with context-aware descriptions
5. Undo history is unlimited (can undo 100+ actions)
</success_criteria>

<output>
After completion, create `.planning/phases/08-workflow-accelerators/08-02-SUMMARY.md`
</output>
