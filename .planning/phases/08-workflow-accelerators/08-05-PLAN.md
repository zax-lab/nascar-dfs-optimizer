---
phase: 08-workflow-accelerators
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/native_mac/gui/views/veto_log_tab.py
  - apps/native_mac/gui/models/veto_log_model.py
  - apps/native_mac/kernel_logger.py
  - apps/native_mac/jobs/job_manager.py
autonomous: true

must_haves:
  truths:
    - "User can view kernel veto logs after optimization completes"
    - "Veto log shows rule name, affected driver, severity, explanation"
    - "User can filter logs by rule type, driver, severity level"
    - "Full-text search works across all veto reason text"
    - "User can export veto logs to JSON/CSV for external analysis"
  artifacts:
    - path: "apps/native_mac/gui/models/veto_log_model.py"
      provides: "VetoLogTableModel for table display"
      min_lines: 150
    - path: "apps/native_mac/gui/views/veto_log_tab.py"
      provides: "VetoLogTab with table view and filters"
      min_lines: 250
    - path: "apps/native_mac/kernel_logger.py"
      provides: "KernelVetoLogger for capturing veto events"
      min_lines: 100
  key_links:
    - from: "KernelVetoLogger"
      to: "OptimizationEngine"
      via: "Interceptor/wrapper for kernel validation calls"
    - from: "VetoLogTableModel"
      to: "QSortFilterProxyModel"
      via: "Filtering and sorting delegation"
    - from: "JobManager"
      to: "VetoLogTab"
      via: "job_completed signal -> display logs for job"
---

<objective>
Create kernel veto log viewer for post-hoc analysis of why lineups were rejected during optimization, with filtering, search, and export capabilities.

Purpose: Users need debugging visibility into constraint violations. Without veto logs, rejected lineups are a black box. This enables tuning constraints and understanding kernel decisions.

Output: KernelVetoLogger for capturing veto events, VetoLogTab UI with table and filters, export to JSON/CSV
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-workflow-accelerators/08-CONTEXT.md
@.planning/phases/08-workflow-accelerators/08-RESEARCH.md
@apps/native_mac/jobs/job_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create KernelVetoLogger for capturing veto events</name>
  <files>apps/native_mac/kernel_logger.py</files>
  <action>
    Create KernelVetoLogger class that captures and stores veto events during optimization.

    Data model for veto events:
    - timestamp: ISO format datetime
    - job_id: UUID of optimization job
    - race_id: Race identifier
    - rule_name: String (e.g., "salary_cap", "team_stacking", "ownership_limit")
    - rule_category: Enum ("constraint", "dk_rule", "stacking", "veto")
    - driver_id: Optional driver identifier (if driver-specific)
    - driver_name: Optional driver name for display
    - severity: Enum ("Info", "Warning", "Error", "Fatal")
    - reason: Human-readable explanation (e.g., "Lineup exceeds $50,000 salary cap")
    - lineup_context: JSON array of driver IDs in rejected lineup
    - constraint_value: The constraint that was violated (if applicable)
    - actual_value: The actual value that caused violation

    Implementation:
    - Store veto events in SQLite (JSON column for flexibility)
    - Table: veto_logs (id, job_id, race_id, timestamp, rule_name, rule_category, driver_id, driver_name, severity, reason, lineup_context, constraint_value, actual_value)
    - Methods:
      - log_veto(job_id, race_id, rule_name, **kwargs): Add veto event
      - get_vetos_for_job(job_id): Return all vetos for a job
      - get_vetos_for_race(race_id): Return all vetos for a race
      - clear_old_vetos(days: int = 30): Delete vetos older than N days
      - export_vetos(job_id, format: str): Export to JSON or CSV

    Integration with kernel:
    - Wrap kernel.validate_lineup() to capture rejections
    - Or use signal/slot pattern if kernel emits events
    - Store veto at time of rejection (during optimization)
    - Link to job_id from JobManager

    Batch capture:
    - Since veto logging is post-hoc (not real-time), capture all vetos during optimization
    - Store in memory during job, flush to database on job completion
    - This avoids DB writes during hot optimization loop
  </action>
  <verify>
    python -c "
    from apps.native_mac.kernel_logger import KernelVetoLogger
    logger = KernelVetoLogger('test_veto.db')
    logger.log_veto(
        job_id='test-job-123',
        race_id='daytona-500',
        rule_name='salary_cap',
        severity='Error',
        reason='Lineup costs $52,000, exceeds $50,000 cap',
        constraint_value=50000,
        actual_value=52000
    )
    vetos = logger.get_vetos_for_job('test-job-123')
    print(f'Logged {len(vetos)} veto events')
    print('KernelVetoLogger OK')
    "
  </verify>
  <done>KernelVetoLogger exists with SQLite storage, log_veto() and query methods working</done>
</task>

<task type="auto">
  <name>Task 2: Create VetoLogTableModel and filtering infrastructure</name>
  <files>apps/native_mac/gui/models/veto_log_model.py</files>
  <action>
    Create VetoLogTableModel for displaying veto logs in table view with filtering support.

    VetoLogTableModel (QAbstractTableModel):
    - Columns: Time, Rule, Driver, Severity, Reason, Lineup
    - Data source: List of veto log dictionaries from KernelVetoLogger
    - Color-code rows by severity (green/yellow/red background)
    - Right-align numeric columns (follow Phase 6 patterns)
    - Implement headerData() for column titles

    Filtering infrastructure:
    - Use QSortFilterProxyModel (Pattern 8 from research)
    - Create VetoLogFilterProxyModel subclass if needed for multi-column filtering
    - Support filters:
      - Rule type (dropdown with distinct rule names)
      - Severity (All, Info, Warning, Error, Fatal)
      - Driver (text search or dropdown)
      - Date range (from/to date pickers)
      - Text search (across reason and rule name columns)

    Data loading:
    - load_for_job(job_id: str): Load all vetos for a specific job
    - load_for_race(race_id: str): Load all vetos for a race
    - refresh(): Reload data from database
    - clear(): Clear model data

    Performance:
    - Veto logs can be large (1000s of entries for big optimizations)
    - Use lazy loading or pagination if needed
    - For MVP: Load all into memory (Qt Model/View handles 10k+ rows fine)

    Header tooltips:
    - Time: "When the lineup was rejected"
    - Rule: "The constraint or rule that was violated"
    - Driver: "Driver involved in violation (if applicable)"
    - Severity: "Impact level (Info=logged, Warning=edge case, Error=rejected)"
    - Reason: "Detailed explanation of violation"
    - Lineup: "Driver IDs in the rejected lineup"
  </action>
  <verify>
    python -c "
    from PySide6.QtWidgets import QApplication
    app = QApplication.instance() or QApplication([])
    from apps.native_mac.gui.models.veto_log_model import VetoLogTableModel
    model = VetoLogTableModel()
    # Test with sample data
    sample_data = [
        {'timestamp': '2026-01-30T10:00:00', 'rule_name': 'salary_cap', 'driver_name': 'Driver A', 
         'severity': 'Error', 'reason': 'Over budget', 'lineup_context': [1,2,3]}
    ]
    model.load_data(sample_data)
    print(f'Model rows: {model.rowCount()}')
    print('VetoLogTableModel OK')
    "
  </verify>
  <done>VetoLogTableModel exists with filtering support, color-coded severity, all columns defined</done>
</task>

<task type="auto">
  <name>Task 3: Create VetoLogTab UI with filters and export</name>
  <files>
    apps/native_mac/gui/views/veto_log_tab.py
    apps/native_mac/main.py
  </files>
  <action>
    Create VetoLogTab UI for browsing, filtering, and exporting veto logs.

    UI layout:
    - Top filter bar (horizontal layout):
      - Job selector dropdown (recent jobs with race name and timestamp)
      - Rule filter: QComboBox (All, Salary Cap, Ownership, Stacking, DK Rules, etc.)
      - Severity filter: QComboBox (All, Info, Warning, Error, Fatal)
      - Driver filter: QLineEdit with placeholder "Filter by driver..."
      - Text search: QLineEdit with placeholder "Search reasons..."
      - Clear filters button
      - Export button (with dropdown: Export as JSON, Export as CSV)

    - Middle: QTableView with VetoLogTableModel
      - Alternating row colors
      - Sortable columns (click headers)
      - Selection: SelectRows
      - Context menu: Copy row, Copy reason, View lineup details

    - Bottom: Status bar
      - Total entries count
      - Filtered entries count
      - Selected job info

    Interactions:
    - Changing any filter updates proxy model filter
    - Job selector loads vetos for that job (via KernelVetoLogger)
    - Export JSON: Opens file dialog, exports visible (filtered) or all entries
    - Export CSV: Same, CSV format with headers
    - Double-click row: Show detailed veto dialog with full lineup context

    Integration:
    - Add "Veto Logs" tab to MainWindow QTabWidget (after Jobs tab)
    - Connect JobManager.job_completed signal to refresh job selector
    - Auto-select most recent completed job on tab activation

    Follow styling patterns from JobsTab:
    - Consistent spacing and margins
    - Status badges with colors
    - Clean filter layout
  </action>
  <verify>
    python -c "
    from PySide6.QtWidgets import QApplication
    app = QApplication.instance() or QApplication([])
    from apps.native_mac.gui.views.veto_log_tab import VetoLogTab
    from apps.native_mac.kernel_logger import KernelVetoLogger
    logger = KernelVetoLogger('test_veto_tab.db')
    tab = VetoLogTab(logger)
    print(f'VetoLogTab created: {tab}')
    print(f'Has table view: {tab.table_view is not None}')
    print('VetoLogTab OK')
    "
  </verify>
  <done>VetoLogTab exists with filter controls, table view, export functionality, integrated in MainWindow</done>
</task>

</tasks>

<verification>
- [ ] KernelVetoLogger captures veto events during optimization
- [ ] Veto logs stored in SQLite with job_id linkage
- [ ] VetoLogTab shows table with Time, Rule, Driver, Severity, Reason columns
- [ ] Severity color-coding works (Info=green, Warning=yellow, Error=red)
- [ ] Filters work: rule type, severity, driver, text search
- [ ] Export to JSON/CSV produces valid files
- [ ] Job selector shows recent jobs and loads their veto logs
- [ ] Veto log tab integrated in MainWindow QTabWidget
</verification>

<success_criteria>
1. User completes optimization and switches to Veto Log tab
2. User sees veto entries showing rejected lineups with rule explanations
3. User filters by "Error" severity to see only rejections
4. User searches "salary" to find salary cap violations
5. User exports veto logs to JSON for analysis in external tool
6. User clicks on veto entry to see full lineup that was rejected
</success_criteria>

<output>
After completion, create `.planning/phases/08-workflow-accelerators/08-05-SUMMARY.md`
</output>
