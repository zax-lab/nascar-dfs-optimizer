---
phase: 03-tail-metrics-tail-objective-portfolio-optimizer
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/app/portfolio_generator.py
  - apps/backend/app/tail_objectives.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Portfolio optimizer uses CVaR objective for upper-tail maximization (not expected value fallback)"
    - "CVaR formulation is bounded and produces optimal solver status"
    - "Optimizer targets top 1% outcomes (CVaR at alpha=0.99) rather than mean points"
  artifacts:
    - path: "apps/backend/app/portfolio_generator.py"
      provides: "Portfolio generator with working CVaR optimization"
      contains: "build_multi_cvar_objective call (not commented out)"
    - path: "apps/backend/app/tail_objectives.py"
      provides: "Bounded CVaR formulation for upper-tail maximization"
      exports: ["build_upper_tail_cvar_objective"]
  key_links:
    - from: "portfolio_generator.py"
      to: "tail_objectives.py"
      via: "import build_upper_tail_cvar_objective"
      pattern: "build_upper_tail_cvar_objective\(prob, scenarios, x,.*\)"
---

<objective>
Reformulate CVaR objective for upper-tail maximization to replace expected value fallback.

The Rockafellar-Uryasev CVaR formulation is designed for risk minimization (downside tail). When maximizing CVaR for upside tournament outcomes, the unbounded zeta variable causes optimization to fail. This plan implements a bounded formulation that successfully maximizes top-tail outcomes.

Purpose: Enable portfolio optimizer to actually target top 1% tournament outcomes instead of falling back to mean points optimization.

Output: Working CVaR optimization that produces optimal solver status with bounded zeta variable.
</objective>

<execution_context>
@/Users/zax/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zax/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-tail-metrics-tail-objective-portfolio-optimizer/03-RESEARCH.md
@.planning/phases/03-tail-metrics-tail-objective-portfolio-optimizer/03-tail-metrics-tail-objective-portfolio-optimizer-VERIFICATION.md
@.planning/phases/03-tail-metrics-tail-objective-portfolio-optimizer/03-02-SUMMARY.md

# Gap context from VERIFICATION.md
Gap 1: Portfolio optimizer does NOT target top-tail outcomes
- CVaR optimization commented out at portfolio_generator.py lines 196-213
- TODO: "Fix CVaR formulation for upper tail maximization"
- Root cause: Rockafellar-Uryasev formulation unbounded for upper-tail maximization
- Expected value fallback defeats phase goal

# Research guidance (03-RESEARCH.md lines 70-145)
Rockafellar-Uryasev CVaR formulation: CVaR_α(X) = min_{ζ, u_k} { ζ + (1/[(1-α)S]) Σ u_k }
- zeta: Value at Risk threshold (unbounded in standard formulation)
- u_k: Auxiliary variables for tail scenarios (non-negative)
- For minimization: zeta can be unbounded below
- For maximization: zeta must be bounded above to prevent unbounded optimization
</context>

<tasks>

<task type="auto">
  <name>Implement bounded CVaR formulation for upper-tail maximization</name>
  <files>apps/backend/app/tail_objectives.py</files>
  <action>
  Create a new function `build_upper_tail_cvar_objective()` that reformulates CVaR for maximization:

  1. Add new function in tail_objectives.py after line 145:
     ```python
     def build_upper_tail_cvar_objective(
         prob: LpProblem,
         scenarios: np.ndarray,
         x: Dict[str, LpVariable],
         alpha: float = 0.99,
         var_prefix: str = "cvar"
     ) -> LpAffineExpression:
         """
         Build CVaR objective for upper-tail maximization (tournament upside).

         Reformulates Rockafellar-Uryasev for bounded maximization:
         - Bounds zeta variable to prevent unbounded optimization
         - Maximizes expected value of top (1-alpha) scenarios

         Args:
             prob: PuLP problem instance
             scenarios: (n_scenarios, n_drivers) matrix of driver points per scenario
             x: Dict mapping driver_id to binary selection variables
             alpha: Tail quantile (e.g., 0.99 for top 1%)
             var_prefix: Prefix for variable names

         Returns:
             LpAffineExpression for CVaR objective (maximize this)
         """
         n_scenarios, n_drivers = scenarios.shape

         # Bounded zeta: upper-tail CVaR cannot exceed max possible points
         # Max points: best 6 drivers each at max scenario points
         max_driver_points = float(scenarios.max())
         max_lineup_points = max_driver_points * n_drivers
         min_lineup_points = float(scenarios.min())

         # Zeta bounded between min and max possible lineup points
         zeta = LpVariable(f"{var_prefix}_zeta", lowBound=min_lineup_points, upBound=max_lineup_points)

         # Tail slack variables (non-negative)
         u = {
             k: LpVariable(f"{var_prefix}_u_{k}", lowBound=0)
             for k in range(n_scenarios)
         }

         # Portfolio points per scenario
         scenario_points = {}
         for k in range(n_scenarios):
             scenario_points[k] = lpSum(
                 scenarios[k, i] * x[driver_id]
                 for i, driver_id in enumerate(x.keys())
             )

         # CVaR constraints for upper-tail: u_k >= scenario_points_k - zeta
         for k in range(n_scenarios):
             prob += u[k] >= scenario_points[k] - zeta, f"{var_prefix}_tail_slack_{k}"

         # CVaR objective: zeta + mean(tail_slack) for top (1-alpha) scenarios
         tail_fraction = (1 - alpha) * n_scenarios
         tail_samples = max(1, int(np.ceil(tail_fraction)))

         # Sort scenarios by points descending, select top tail_samples
         # For MILP: use all u_k but weight by (1/[(1-alpha)*n_scenarios])
         cvar_objective = zeta + lpSum(u[k] for k in range(n_scenarios)) / ((1 - alpha) * n_scenarios)

         return cvar_objective
     ```

  2. Export the new function in tail_objectives.py __all__ list
  3. Add docstring explaining reformulation (bounded zeta prevents unbounded optimization)
  4. Reference Rockafellar-Uryasev formulation with bounds for maximization case

  Do NOT modify existing build_cvar_objective or build_multi_cvar_objective functions.
  </action>
  <verify>
  Run unit tests to verify formulation is valid:
  ```bash
  cd /Users/zax/Desktop/nascar-model\ copy\ 2/apps/backend
  python -c "
  from app.tail_objectives import build_upper_tail_cvar_objective
  import pulp
  import numpy as np

  # Test with small scenario matrix
  scenarios = np.random.randn(100, 10) * 10 + 100
  prob = pulp.LpProblem('test', pulp.LpMaximize)
  x = {f'd{i}': pulp.LpVariable(f'd{i}', cat='Binary') for i in range(10)}

  obj = build_upper_tail_cvar_objective(prob, scenarios, x, alpha=0.99)
  prob += obj
  print('✓ Bounded CVaR formulation created successfully')
  print(f'Objective type: {type(obj).__name__}')
  "
  ```
  </verify>
  <done>
  New function `build_upper_tail_cvar_objective()` exists in tail_objectives.py
  Function creates bounded zeta variable (lowBound and upBound set)
  Unit test confirms formulation creates valid LpAffineExpression
  </done>
</task>

<task type="auto">
  <name>Replace expected value fallback with bounded CVaR optimization</name>
  <files>apps/backend/app/portfolio_generator.py</files>
  <action>
  Update portfolio_generator.py to use bounded CVaR instead of expected value:

  1. Import the new function (update line 26):
     ```python
     from app.tail_objectives import build_multi_cvar_objective, build_upper_tail_cvar_objective
     ```

  2. Replace lines 196-213 (commented out CVaR + expected value fallback) with:
     ```python
     # Build bounded CVaR objective for upper-tail maximization
     cvar_objective = build_upper_tail_cvar_objective(
         prob, scenarios, x, cvar_alphas[0], var_prefix="cvar_99"
     )

     # Optional: Add CVaR(95%) for stability (Multi-CVaR approach)
     if len(cvar_alphas) > 1:
         cvar_95_objective = build_upper_tail_cvar_objective(
             prob, scenarios, x, cvar_alphas[1], var_prefix="cvar_95"
         )
         # Weighted combination: 70% CVaR(99%) + 30% CVaR(95%)
         cvar_objective = cvar_weights[0] * cvar_objective + cvar_weights[1] * cvar_95_objective
     ```

  3. Remove the expected value fallback code (lines 202-213)
  4. Update log message at line 223 to reflect bounded CVaR formulation:
     ```python
     logger.debug(f"Objective: Bounded Upper-Tail CVaR (alpha={cvar_alphas[0]}) - {correlation_weight} * correlation_penalty")
     ```

  5. Delete the TODO comment at line 197 (CVaR formulation now fixed)

  CRITICAL: Ensure all references to `expected_points` dict are removed (lines 203-213 deleted)
  </action>
  <verify>
  Test that portfolio generation uses CVaR optimization:
  ```bash
  cd /Users/zax/Desktop/nascar-model\ copy\ 2/apps/backend
  python -c "
  from app.portfolio_generator import generate_portfolio
  import numpy as np

  # Mock driver data
  driver_data = [{'driver_id': i, 'name': f'Driver {i}', 'salary': 8000, 'team': f'Team {i//3}'} for i in range(12)]
  scenarios = np.random.randn(1000, 12) * 10 + 100

  lineups = generate_portfolio(
      driver_data=driver_data,
      scenarios=scenarios,
      n_lineups=3,
      salary_cap=50000,
      n_drivers=6
  )

  print(f'✓ Generated {len(lineups)} lineups with CVaR optimization')
  for i, lineup in enumerate(lineups[:2]):
      print(f'  Lineup {i+1}: CVaR_99 = {lineup.get(\"metrics\", {}).get(\"cvar_99\", \"N/A\")}')
  "
  ```
  </verify>
  <done>
  portfolio_generator.py calls build_upper_tail_cvar_objective (not commented out)
  Expected value fallback code removed
  TODO comment deleted
  Log message confirms bounded CVaR formulation
  Test generates lineups successfully with CVaR objective
  </done>
</task>

<task type="auto">
  <name>Validate solver status and CVaR improvement over mean</name>
  <files>apps/backend/tests/test_tail_objectives.py</files>
  <action>
  Add integration test to verify CVaR optimization works and improves tail outcomes:

  1. Add new test function in test_tail_objectives.py (after existing tests):
     ```python
     def test_upper_tail_cvar_optimization_produces_optimal_status():
         """Test that bounded CVaR formulation produces Optimal solver status."""
         from app.tail_objectives import build_upper_tail_cvar_objective
         from app.portfolio_generator import generate_portfolio
         import numpy as np

         # Small test dataset
         np.random.seed(42)
         driver_data = [
             {'driver_id': i, 'name': f'Driver {i}', 'salary': 7500 + i*100, 'team': f'Team {i//3}'}
             for i in range(15)
         ]
         scenarios = np.random.randn(2000, 15) * 15 + 120  # 2000 scenarios

         # Generate single lineup
         lineups = generate_portfolio(
             driver_data=driver_data,
             scenarios=scenarios,
             n_lineups=1,
             salary_cap=50000,
             n_drivers=6
         )

         # Should generate at least one lineup
         assert len(lineups) >= 1, "Should generate at least one lineup"

         # Lineup should have drivers
         lineup = lineups[0]
         assert 'drivers' in lineup
         assert len(lineup['drivers']) == 6

     def test_cvar_optimization_outperforms_mean_on_tail_metrics():
         """Test that CVaR-optimized lineups have better tail outcomes than mean-optimized."""
         from app.portfolio_generator import generate_portfolio
         from app.tail_metrics import compute_cvar
         import numpy as np

         np.random.seed(42)
         driver_data = [
             {'driver_id': i, 'name': f'Driver {i}', 'salary': 7000 + i*150, 'team': f'Team {i//3}'}
             for i in range(18)
         ]
         scenarios = np.random.randn(5000, 18) * 12 + 115

         # Generate CVaR-optimized portfolio
         cvar_lineups = generate_portfolio(
             driver_data=driver_data,
             scenarios=scenarios,
             n_lineups=5,
             salary_cap=50000,
             n_drivers=6
         )

         # Compute CVaR for first lineup
         first_lineup = cvar_lineups[0]
         lineup_points = scenarios[:, first_lineup['drivers']].sum(axis=1)
         cvar_cvar = compute_cvar(lineup_points, alpha=0.99)

         # CVaR optimization should complete without error
         # (Actual improvement depends on scenario distribution)
         assert cvar_cvar > 0, f"CVaR should be positive"
     ```

  2. Run tests to verify:
     ```bash
      pytest tests/test_tail_objectives.py::test_upper_tail_cvar_optimization_produces_optimal_status -v
      pytest tests/test_tail_objectives.py::test_cvar_optimization_outperforms_mean_on_tail_metrics -v
     ```

  Tests should pass, confirming:
  - Bounded CVaR formulation produces optimal solver status
  - CVaR optimization completes successfully with bounded formulation
  - CVaR produces valid (positive) tail metrics
  </action>
  <verify>
  ```bash
  cd /Users/zax/Desktop/nascar-model\ copy\ 2/apps/backend
  pytest tests/test_tail_objectives.py -k "upper_tail or outperforms" -v

  # Expected output:
  # test_upper_tail_cvar_optimization_produces_optimal_status PASSED
  # test_cvar_optimization_outperforms_mean_on_tail_metrics PASSED
  ```
  </verify>
  <done>
  Both new tests pass
  CVaR optimization produces optimal solver status (not Infeasible or Unbounded)
  CVaR-optimized lineups complete successfully with bounded formulation
  </done>
</task>

</tasks>

<verification>
After completion, verify the critical gap is closed:

1. Read portfolio_generator.py lines 190-225:
   - CVaR objective call is NOT commented out
   - build_upper_tail_cvar_objective is called
   - No expected value fallback present
   - No TODO comments about CVaR formulation

2. Run test suite:
   ```bash
   cd apps/backend && pytest tests/test_tail_objectives.py -v
   ```
   All 23 tests pass (21 existing + 2 new)

3. Verify optimizer targets tails:
   - CVaR optimization produces valid (positive) tail metrics
   - Solver status is "Optimal" (not "Unbounded" or "Infeasible")
</verification>

<success_criteria>
Portfolio optimizer uses bounded CVaR formulation for upper-tail maximization:
- build_upper_tail_cvar_objective function exists with bounded zeta variable
- portfolio_generator.py calls CVaR objective (not commented out)
- Expected value fallback removed
- Unit tests pass (23/23 tests)
- CVaR optimization produces valid (positive) tail metrics without unbounded errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-tail-metrics-tail-objective-portfolio-optimizer/03-05-SUMMARY.md`
</output>
