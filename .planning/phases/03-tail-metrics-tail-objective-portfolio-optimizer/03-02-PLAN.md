---
phase: 03-tail-metrics-tail-objective-portfolio-optimizer
plan: 02
type: execute
wave: 1
depends_on: [03-01]
files_modified:
  - apps/backend/app/tail_objectives.py
  - apps/backend/app/tests/test_tail_objectives.py
autonomous: true

must_haves:
  truths:
    - "CVaR objective builders create PuLP auxiliary variables (zeta, u_k) for Rockafellar-Uryasev formulation"
    - "Multi-CVaR combines CVaR(99%) and CVaR(95%) with configurable weights for stability"
    - "Portfolio points per scenario computed as linear combination of driver selections"
    - "Unit tests validate objective function value matches manual CVaR calculation"
    - "Solver can optimize for CVaR objective and converge to optimal solution"
  artifacts:
    - path: "apps/backend/app/tail_objectives.py"
      provides: "CVaR objective builders for MILP optimization"
      exports: ["build_cvar_objective", "build_multi_cvar_objective", "add_cvar_constraints"]
      min_lines: 200
    - path: "apps/backend/app/tests/test_tail_objectives.py"
      provides: "Unit tests for CVaR objective builders"
      min_lines: 150
  key_links:
    - from: "apps/backend/app/tail_objectives.py"
      to: "apps/backend/app/tail_metrics.py"
      via: "Import compute_cvar for post-hoc validation"
      pattern: "from app.tail_metrics import compute_cvar"
    - from: "apps/backend/app/tail_objectives.py"
      to: "apps/backend/app/optimizer.py"
      via: "Integrate with existing NASCAROptimizer PuLP problems"
      pattern: "from pulp import LpProblem, LpVariable"
    - from: "apps/backend/app/tail_objectives.py"
      to: "packages/axiomatic-sim/src/axiomatic_sim/scenario_generator.py"
      via: "ScenarioComponents converted to scenario matrices"
      pattern: "scenarios\\[k, i\\].*driver\\[i\\]"
---

<objective>
Build CVaR objective builders that integrate tail optimization into PuLP MILP problems. This enables the optimizer to directly maximize top-tail outcomes rather than mean points.

Purpose: Convert tail metrics from Phase 3 Plan 01 into solvable MILP objectives using Rockafellar-Uryasev formulation with auxiliary variables, enabling portfolio optimization for tournament equity.

Output: Working tail_objectives.py module with CVaR constraint builders, Multi-CVaR stability optimization, scenario point computation helpers, and comprehensive unit tests.
</objective>

<execution_context>
@/Users/zax/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zax/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-tail-metrics-tail-objective-portfolio-optimizer/03-CONTEXT.md
@.planning/phases/03-tail-metrics-tail-objective-portfolio-optimizer/03-RESEARCH.md

# Phase 3 Plan 01 outputs
@apps/backend/app/tail_metrics.py

# Existing optimizer
@apps/backend/app/optimizer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Rockafellar-Uryasev CVaR objective builder</name>
  <files>apps/backend/app/tail_objectives.py</files>
  <action>
Create tail_objectives.py module with CVaR objective builders:

1. **build_cvar_objective()** function:
```python
def build_cvar_objective(
    prob: LpProblem,
    scenarios: np.ndarray,
    x: Dict[int, LpVariable],
    alpha: float = 0.99
) -> pulp.LpAffineExpression:
    """
    Build CVaR objective using Rockafellar-Uryasev formulation.

    CVaR_α = min_ζ { ζ + (1/[(1-α)S]) Σ_{k=1}^S max(0, loss_k - ζ) }

    For maximization (DFS points), we use:
    CVaR_α = max_ζ { ζ + (1/[(1-α)S]) Σ_{k=1}^S max(0, points_k - ζ) }

    Args:
        prob: PuLP problem to add variables/constraints to
        scenarios: ndarray (n_scenarios, n_drivers) with DFS points per scenario
        x: Dict mapping driver_id -> binary selection variable
        alpha: Tail quantile (e.g., 0.99 for top 1%)

    Returns:
        PuLP expression for CVaR objective (to be maximized)
    """
```

2. **Implementation steps:**
   a. Extract dimensions: n_scenarios, n_drivers = scenarios.shape
   b. Create CVaR auxiliary variables:
      - zeta = LpVariable("zeta", lowBound=None, cat="Continuous")
      - u = {k: LpVariable(f"tail_slack_{k}", lowBound=0) for k in range(n_scenarios)}
   c. Compute portfolio points per scenario:
      ```python
      scenario_points = {}
      for k in range(n_scenarios):
          scenario_points[k] = lpSum(
              scenarios[k, i] * x[i] for i in range(n_drivers)
          )
      ```
   d. Add CVaR constraints (u_k >= scenario_points_k - zeta, u_k >= 0):
      ```python
      for k in range(n_scenarios):
          prob += u[k] >= scenario_points[k] - zeta, f"Tail_Slack_{k}"
      ```
   e. Build and return CVaR objective expression:
      ```python
      cvar = zeta + lpSum(u[k] for k in range(n_scenarios)) / ((1 - alpha) * n_scenarios)
      return cvar
      ```

3. **Helper: compute_scenario_points()**
   - Input: scenarios (ndarray), driver_selection (list of driver_ids)
   - Output: ndarray (n_scenarios,) with portfolio points per scenario
   - Sum driver points for each scenario

DO NOT use VaR instead of CVaR (VaR is not coherent, CVaR is standard).
DO NOT forget u_k >= 0 constraint (Rockafellar-Uryasev requires non-negative slack).
DO use lpSum for linear combinations (PuLP handles symbolic expressions).
DO add descriptive constraint names (helps debugging solver issues).

Reference: 03-RESEARCH.md "Pattern 1: Rockafellar-Uryasev CVaR MILP Formulation"
  </action>
  <verify>
Run: python3 -c "
from app.tail_objectives import build_cvar_objective
from pulp import LpProblem, LpVariable, LpMaximize
import numpy as np

# Create test problem
prob = LpProblem('Test_CVaR', LpMaximize)
scenarios = np.random.randn(100, 5)  # 100 scenarios, 5 drivers
x = {i: LpVariable(f'driver_{i}', cat='Binary') for i in range(5)}

# Build CVaR objective
cvar_expr = build_cvar_objective(prob, scenarios, x, alpha=0.99)
prob += cvar_expr, 'CVaR_Objective'

print(f'Objective built: {cvar_expr}')
print(f'Problem has {len(prob.variables())} variables')
print(f'Problem has {len(prob.constraints)} constraints')
"
Expected: Output shows CVaR expression, >100 variables (5 binary + 1 zeta + 100 u_k), 100 constraints
  </verify>
  <done>
build_cvar_objective() returns PuLP expression for CVaR
Problem has correct number of variables (n_drivers binary + 1 zeta + n_scenarios u_k)
All CVaR constraints added (u_k >= scenario_points_k - zeta for all k)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Multi-CVaR objective for stability</name>
  <files>apps/backend/app/tail_objectives.py</files>
  <action>
Add Multi-CVaR objective builder combining CVaR at multiple quantiles:

1. **build_multi_cvar_objective()** function:
```python
def build_multi_cvar_objective(
    prob: LpProblem,
    scenarios: np.ndarray,
    x: Dict[int, LpVariable],
    alphas: List[float] = [0.99, 0.95],
    weights: List[float] = [0.7, 0.3]
) -> pulp.LpAffineExpression:
    """
    Build Multi-CVaR objective for stability.

    Combines CVaR at multiple quantiles to stabilize estimation
    while preserving tail focus.

    Args:
        prob: PuLP problem to add variables/constraints to
        scenarios: ndarray (n_scenarios, n_drivers) with DFS points
        x: Dict mapping driver_id -> binary selection variable
        alphas: List of tail quantiles (e.g., [0.99, 0.95])
        weights: List of weights for each quantile (must sum to 1.0)

    Returns:
        PuLP expression for weighted Multi-CVaR objective
    """
```

2. **Implementation steps:**
   a. Validate inputs: len(alphas) == len(weights), sum(weights) == 1.0
   b. Call build_cvar_objective() for each alpha with unique variable names:
      - Use f"zeta_{alpha}" for zeta variables (avoid naming conflicts)
      - Use f"tail_slack_{alpha}_{k}" for u_k variables
   c. Combine objectives with weights:
      ```python
      multi_cvar = lpSum(
          weights[i] * cvar_objs[i]
          for i in range(len(alphas))
      )
      return multi_cvar
      ```

3. **Helper: add_cvar_constraints()** (alternative API):
   - Same logic as build_cvar_objective() but returns (zeta, u, cvar_expr)
   - Allows manual combination of multiple CVaR objectives

4. **Default weights:** 70% CVaR(99%) + 30% CVaR(95%)
   - Research shows this balances stability and tail focus
   - Make weights configurable for empirical testing

DO NOT use single quantile CVaR (unstable with limited scenarios).
DO NOT use equal weights (literature recommends 60-80% on extreme quantile).
DO validate weights sum to 1.0 (otherwise objective scale is wrong).
DO use unique variable names for multiple quantiles (prevents naming conflicts).

Reference: 03-RESEARCH.md "Open Questions: Optimal Multi-CVaR Weights"
  </action>
  <verify>
Run: python3 -c "
from app.tail_objectives import build_multi_cvar_objective
from pulp import LpProblem, LpVariable, LpMaximize
import numpy as np

# Create test problem
prob = LpProblem('Test_Multi_CVaR', LpMaximize)
scenarios = np.random.randn(100, 5)
x = {i: LpVariable(f'driver_{i}', cat='Binary') for i in range(5)}

# Build Multi-CVaR objective (99% + 95%)
multi_cvar = build_multi_cvar_objective(prob, scenarios, x, alphas=[0.99, 0.95], weights=[0.7, 0.3])
prob += multi_cvar, 'Multi_CVaR_Objective'

print(f'Multi-CVaR objective: {multi_cvar}')
print(f'Variables: {len(prob.variables())}')
print(f'Constraints: {len(prob.constraints)}')

# Check variable names for uniqueness
var_names = [v.name for v in prob.variables()]
print(f'Unique zeta vars: {sum(1 for n in var_names if \"zeta\" in n)}')
print(f'Unique u vars: {sum(1 for n in var_names if \"tail_slack\" in n)}')
"
Expected: 2 zeta variables (zeta_0.99, zeta_0.95), 200 u variables (100 per quantile), 200 constraints
  </verify>
  <done>
build_multi_cvar_objective() combines CVaR(99%) and CVaR(95%) with weights
Unique variable names for each quantile (no naming conflicts)
Weights validated to sum to 1.0
Multi-CVaR expression returned as PuLP linear combination
  </done>
</task>

<task type="auto">
  <name>Task 3: Create unit tests for CVaR objectives</name>
  <files>apps/backend/app/tests/test_tail_objectives.py</files>
<action>
Create test_tail_objectives.py with comprehensive unit tests:

1. **test_build_cvar_objective_variables():**
   - Create problem, scenarios (10 scenarios, 5 drivers)
   - Call build_cvar_objective()
   - Assert problem has 5 binary vars + 1 zeta + 10 u_k = 16 total variables
   - Assert all u_k variables have lowBound=0 (non-negative constraint)

2. **test_build_cvar_objective_constraints():**
   - After building objective, count constraints
   - Assert 10 constraints exist (one per scenario)
   - Assert constraint names follow pattern "Tail_Slack_{k}"

3. **test_multi_cvar_objective_weights():**
   - Build Multi-CVaR with alphas=[0.99, 0.95], weights=[0.7, 0.3]
   - Validate expression is weighted sum: 0.7 * CVaR(99%) + 0.3 * CVaR(95%)
   - Test with weights=[1.0, 0.0] (pure CVaR(99%))
   - Test with weights=[0.0, 1.0] (pure CVaR(95%))

4. **test_scenario_points_computation():**
   - Create scenarios with known values
   - Select specific drivers: x = {0: 1, 2: 1, 4: 1, others: 0}
   - Compute scenario_points manually
   - Assert matches compute_scenario_points() output

5. **test_cvar_optimization_converges():**
   - Create simple optimization problem:
     - 3 drivers, 10 scenarios
     - Constraint: select exactly 2 drivers
     - Objective: maximize CVaR(99%)
   - Solve with CBC solver
   - Assert solver status is "Optimal"
   - Assert selected drivers have highest tail performance

6. **test_multi_cvar_stability():**
   - Create scenarios with noisy tail (high variance)
   - Optimize with pure CVaR(99%) and Multi-CVaR (99% + 95%)
   - Run optimization 10 times with different random seeds
   - Assert Multi-CVaR has lower lineup variance (more stable)

DO NOT skip solver integration test (must verify optimization works end-to-end).
DO NOT use small scenario counts (<10) in tests (unstable tail estimates).
DO validate zeta and u_k variable types (zeta is continuous, u_k is continuous with lowBound=0).
DO test weight validation (sum to 1.0, len matches alphas).

Reference: 03-RESEARCH.md "Pitfall 2: Mean-Optimized Tail (Optimizer Secretly Targets Mean)"
  </action>
  <verify>
Run: cd apps/backend && python3 -m pytest tests/test_tail_objectives.py -v
Expected: All 6 tests pass, solver converges to optimal solutions
Run: python3 -m pytest tests/test_tail_objectives.py --cov=app.tail_objectives --cov-report=term-missing
Expected: Coverage > 85% for tail_objectives.py
  </verify>
  <done>
All 6 unit tests pass with solver convergence validation
CVaR objective creates correct variables and constraints
Multi-CVaR weights validated and combined correctly
Scenario points computation matches manual calculation
Multi-CVaR shows improved stability vs pure CVaR(99%)
Coverage > 85% for tail_objectives.py
  </done>
</task>

</tasks>

<verification>
## Phase Verification Criteria

### Core Functionality
1. CVaR objective builders create PuLP auxiliary variables (zeta, u_k) for Rockafellar-Uryasev formulation
2. Multi-CVaR combines CVaR(99%) and CVaR(95%) with configurable weights
3. Portfolio points per scenario computed as linear combination of driver selections
4. Unit tests validate objective function value matches manual CVaR calculation
5. Solver can optimize for CVaR objective and converge to optimal solution

### Integration Points
1. build_cvar_objective() integrates with existing PuLP problems in optimizer.py
2. Scenario matrices from Phase 2 CBN sampling can be used directly
3. CVaR expression can be added to problem with prob += cvar_expr
4. Multi-CVaR weights configurable for empirical testing

### Avoidance Checks
1. No VaR usage (must use CVaR for coherent risk measure)
2. No missing u_k >= 0 constraint (Rockafellar-Uryasev requires non-negative slack)
3. No single-quantile CVaR without stability checks (must use Multi-CVaR or adaptive thresholds)
4. No hardcoded weights (must be configurable for research into optimal values)
</verification>

<success_criteria>
1. build_cvar_objective() creates correct variables (n_drivers binary + 1 zeta + n_scenarios u_k)
2. CVaR constraints added for all scenarios (u_k >= scenario_points_k - zeta)
3. build_multi_cvar_objective() combines multiple quantiles with validated weights
4. Solver converges to optimal solution with CVaR objective
5. All 6 unit tests pass with >85% code coverage
6. Multi-CVaR shows improved stability vs pure CVaR(99%) in variance test
7. Scenario points computation matches manual calculation
</success_criteria>

<output>
After completion, create `.planning/phases/03-tail-metrics-tail-objective-portfolio-optimizer/03-02-SUMMARY.md`
</output>
