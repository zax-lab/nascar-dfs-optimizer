---
phase: 04-field-ownership-contest-sim
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/app/contest/__init__.py
  - apps/backend/app/contest/payout_curve.py
  - apps/backend/app/contest/models.py
autonomous: true

must_haves:
  truths:
    - "System can predict payout for any finish position in a contest"
    - "Payout predictions are accurate within 5% of historical actuals"
    - "System handles different contest sizes (small <5K, medium 5K-20K, large >20K)"
    - "Payout curve fits validated with R² > 0.90 for quality assurance"
    - "Contest Pydantic models validate payout data"
  artifacts:
    - path: "apps/backend/app/contest/payout_curve.py"
      provides: "PayoutCurveFitter and PayoutCurve classes"
      exports: ["PayoutCurveFitter", "PowerLawPayoutCurve", "ExponentialPayoutCurve"]
      min_lines: 250
    - path: "apps/backend/app/contest/models.py"
      provides: "Pydantic models for contest data"
      exports: ["PayoutData", "PayoutCurveFit", "ContestSize"]
      min_lines: 100
  key_links:
    - from: "apps/backend/app/contest/payout_curve.py"
      to: "scipy.optimize"
      via: "curve_fit for parametric fitting"
      pattern: "from scipy.optimize import curve_fit"
    - from: "apps/backend/app/contest/models.py"
      to: "apps/backend/app/models.py"
      via: "Pydantic model patterns"
      pattern: "from pydantic import BaseModel"
---

<objective>
Build payout curve modeling infrastructure to approximate DraftKings GPP payout structures. This fits parametric models (power-law, exponential) to historical contest data and enables interpolation for unobserved finish positions.

Purpose: Model payout structures for contest simulation, enabling accurate ROI calculation from finish position
Output: PayoutCurveFitter with power-law and exponential models, fit quality metrics, and contest Pydantic models
</objective>

<execution_context>
@/Users/zax/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zax/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-field-ownership-contest-sim/04-CONTEXT.md
@.planning/phases/04-field-ownership-contest-sim/04-RESEARCH.md

# Reference existing Pydantic models
@apps/backend/app/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create payout curve models</name>
  <files>apps/backend/app/contest/payout_curve.py, apps/backend/app/contest/__init__.py</files>
  <action>
Create payout curve fitting infrastructure:

**File: apps/backend/app/contest/__init__.py**
- Export PayoutCurveFitter, PowerLawPayoutCurve, ExponentialPayoutCurve
- Add module docstring explaining payout curve modeling approach

**File: apps/backend/app/contest/payout_curve.py**

Create base PayoutCurve class:
- Abstract base class with predict(ranks) method
- Method predict(ranks) should accept array of ranks, return array of payouts
- Subclasses implement specific parametric forms

Create PowerLawPayoutCurve class:
- __init__(a, b):
  - a: Scaling parameter (payout at rank=1)
  - b: Decay exponent (higher = faster decay)
- Function: payout = a * rank^(-b)
- predict(ranks) method:
  - Apply power-law formula to ranks array
  - Handle zero/negative ranks with error
  - Return payouts array

Create ExponentialPayoutCurve class:
- __init__(a, b):
  - a: Scaling parameter
  - b: Decay rate
- Function: payout = a * exp(-b * rank)
- predict(ranks) method:
  - Apply exponential formula to ranks array
  - Return payouts array

Create PayoutCurveFitter class:
- __init__(curve_type='power_law'):
  - curve_type: 'power_law', 'exponential', or 'auto' (choose best fit)
  - contest_size_tier: 'small' (<5K), 'medium' (5K-20K), 'large' (>20K)
- fit(ranks, payouts):
  - Accept ranks array (1, 2, 3, ...) and payouts array
  - Use scipy.optimize.curve_fit to fit parametric model
  - Handle both power-law and exponential fitting
  - Store fitted parameters (a, b)
  - Compute R² and RMSE for fit quality
  - Log fit diagnostics (parameters, R², RMSE)
  - Return self
- predict(ranks):
  - Use fitted curve to predict payouts for new ranks
  - Interpolate for unobserved ranks (power-law extrapolates smoothly)
  - Return payouts array
- get_curve():
  - Return fitted curve object (PowerLawPayoutCurve or ExponentialPayoutCurve)
- get_fit_quality():
  - Return dict with r_squared, rmse, n_observations

DO NOT:
- Don't add piecewise linear models yet (keep it simple with parametric)
- Don't add hybrid models yet (can extend later if needed)

Reference RESEARCH.md section "Payout Curve Modeling" for complete implementation examples.
  </action>
  <verify>
```bash
cd /Users/zax/Desktop/nascar-model\ copy\ 2
python -c "
from apps.backend.app.contest.payout_curve import (
    PayoutCurveFitter,
    PowerLawPayoutCurve,
    ExponentialPayoutCurve
)
import numpy as np

# Historical payout data
ranks = np.array([1, 2, 3, 5, 10, 20, 50, 100])
payouts = np.array([100000, 50000, 30000, 15000, 5000, 2000, 500, 200])

# Test power-law fitting
fitter = PayoutCurveFitter(curve_type='power_law')
fitter.fit(ranks, payouts)
predictions = fitter.predict(np.array([1, 2, 3, 15, 50]))
quality = fitter.get_fit_quality()

print('Power-law payout curve test passed')
print(f'Predictions: {predictions}')
print(f'Fit quality: R²={quality[\"r_squared\"]:.4f}, RMSE={quality[\"rmase\"]:.2f}')

# Test exponential fitting
fitter_exp = PayoutCurveFitter(curve_type='exponential')
fitter_exp.fit(ranks, payouts)
predictions_exp = fitter_exp.predict(np.array([1, 2, 3, 15, 50]))
print(f'Exponential predictions: {predictions_exp}')
"
```
  </verify>
  <done>
Payout curve models created with:
- PowerLawPayoutCurve: payout = a * rank^(-b)
- ExponentialPayoutCurve: payout = a * exp(-b * rank)
- PayoutCurveFitter: fits curves using scipy.optimize.curve_fit
- Fit quality metrics: R², RMSE
- Interpolation for unobserved ranks
  </done>
</task>

<task type="auto">
  <name>Task 2: Create contest Pydantic models</name>
  <files>apps/backend/app/contest/models.py</files>
  <action>
Create Pydantic models for contest data:

**File: apps/backend/app/contest/models.py**

Create PayoutData model:
- rank: int
- payout: float
- contest_id: Optional[str] = None

Create PayoutCurveFit model:
- curve_type: str  # 'power_law' or 'exponential'
- parameters: Dict[str, float]  # {'a': 100000, 'b': 1.5}
- fit_quality: Dict[str, float]  # {'r_squared': 0.95, 'rmse': 500}
- contest_size_tier: str  # 'small', 'medium', 'large'
- n_observations: int
- fitted_at: datetime

Create ContestSize model:
- contest_size: int
- tier: str  # 'small', 'medium', 'large'
- buyin: float
- total_prize_pool: float
- n_paid: int  # Number of positions that cash

Create HistoricalContestData model:
- contest_id: str
- contest_size: int
- buyin: float
- payouts: List[PayoutData]
- contest_date: datetime
- track_archetype: Optional[str] = None

Add validation:
- rank must be positive
- payout must be non-negative
- contest_size must be positive
- tier must be one of: small, medium, large
- curve_type must be one of: power_law, exponential

Reference existing Pydantic models in apps/backend/app/models.py for patterns.
  </action>
  <verify>
```bash
cd /Users/zax/Desktop/nascar-model\ copy\ 2
python -c "
from apps.backend.app.contest.models import (
    PayoutData,
    PayoutCurveFit,
    ContestSize,
    HistoricalContestData
)
from datetime import datetime

# Create sample payout data
payout_data = PayoutData(rank=1, payout=100000, contest_id='test-123')

# Create sample curve fit
curve_fit = PayoutCurveFit(
    curve_type='power_law',
    parameters={'a': 100000, 'b': 1.5},
    fit_quality={'r_squared': 0.95, 'rmse': 500},
    contest_size_tier='large',
    n_observations=100,
    fitted_at=datetime.now()
)

# Create sample contest size
contest_size = ContestSize(
    contest_size=10000,
    tier='large',
    buyin=20.0,
    total_prize_pool=200000,
    n_paid=1500
)

# Create sample historical contest
contest = HistoricalContestData(
    contest_id='dk-2024-02-18-gpp',
    contest_size=10000,
    buyin=20.0,
    payouts=[payout_data],
    contest_date=datetime(2024, 2, 18),
    track_archetype='superspeedway'
)

print('Contest models test passed')
print(f'Curve fit R²: {curve_fit.fit_quality[\"r_squared\"]}')
print(f'Contest tier: {contest_size.tier}')
"
```
  </verify>
  <done>
Pydantic models created with:
- PayoutData validates rank/payout pairs
- PayoutCurveFit stores fitted curve parameters
- ContestSize classifies contest size tier
- HistoricalContestData stores historical contest data
- All models validate input ranges
  </done>
</task>

<task type="auto">
  <name>Task 3: Add payout curve utilities</name>
  <files>apps/backend/app/contest/payout_curve.py</files>
  <action>
Add utility functions to payout_curve.py:

Add function load_historical_payouts(contest_id: str, db: Session):
- Query historical contest data from database
- Return ranks and payouts arrays
- Handle missing contest_id with error
- Use SQLAlchemy to query contest_results table

Add function fit_payout_curves_by_tier(historical_contests: List[HistoricalContestData]):
- Group contests by size tier (small, medium, large)
- Fit separate payout curve for each tier
- Return dict mapping tier -> PayoutCurveFitter
- Log fit quality for each tier
- Handle insufficient data with warning

Add function get_payout_curve_for_contest(contest_size: int, curves_by_tier: Dict[str, PayoutCurveFitter]):
- Determine tier from contest_size
- Return appropriate curve fitter
- Handle edge cases (contest_size between tiers)

Add function interpolate_payout_for_rank(rank: int, curve: PayoutCurveFitter):
- Predict payout for specific rank
- Handle rank > contest_size with extrapolation warning
- Return payout amount

DO NOT:
- Don't add automatic curve selection yet (use manual tier selection)
- Don't add payout curve caching yet (that's for API integration)

Reference RESEARCH.md section on payout curve utilities.
  </action>
  <verify>
```bash
cd /Users/zax/Desktop/nascar-model\ copy\ 2
python -c "
from apps.backend.app.contest.payout_curve import (
    PayoutCurveFitter,
    fit_payout_curves_by_tier,
    get_payout_curve_for_contest,
    interpolate_payout_for_rank
)
import numpy as np
from apps.backend.app.contest.models import HistoricalContestData, PayoutData
from datetime import datetime

# Create sample historical contests
contests = [
    HistoricalContestData(
        contest_id='small-1',
        contest_size=3000,
        buyin=3.0,
        payouts=[
            PayoutData(rank=i+1, payout=3000 / (i+1)**1.5)
            for i in range(100)
        ],
        contest_date=datetime.now()
    ),
    HistoricalContestData(
        contest_id='large-1',
        contest_size=15000,
        buyin=20.0,
        payouts=[
            PayoutData(rank=i+1, payout=100000 / (i+1)**1.2)
            for i in range(500)
        ],
        contest_date=datetime.now()
    )
]

# Fit curves by tier
curves = fit_payout_curves_by_tier(contests)
print(f'Fitted {len(curves)} tier curves')

# Get curve for specific contest
curve = get_payout_curve_for_contest(10000, curves)
payout = interpolate_payout_for_rank(50, curve)
print(f'Payout for rank 50 in 10K contest: ${payout:.2f}')

print('Payout curve utilities test passed')
"
```
  </verify>
  <done>
Payout curve utilities added with:
- load_historical_payouts() queries database for historical data
- fit_payout_curves_by_tier() fits curves per contest size tier
- get_payout_curve_for_contest() selects appropriate curve
- interpolate_payout_for_rank() predicts payout for specific rank
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. **Payout curve fitting**: Power-law and exponential models fit to historical data
2. **Fit quality**: R² and RMSE computed correctly
3. **Interpolation**: Curve extrapolates to unobserved ranks
4. **Contest tiering**: Separate curves for small/medium/large contests
5. **Pydantic validation**: All contest models validate correctly

Run verification:
```bash
cd /Users/zax/Desktop/nascar-model\ copy\ 2
python -c "
from apps.backend.app.contest.payout_curve import PayoutCurveFitter
from apps.backend.app.contest.models import PayoutCurveFit, HistoricalContestData
import numpy as np

# Quick test
ranks = np.array([1, 2, 3, 5, 10])
payouts = np.array([1000, 500, 300, 150, 50])
fitter = PayoutCurveFitter()
fitter.fit(ranks, payouts)
preds = fitter.predict(np.array([1, 2, 7]))
print(f'Predictions: {preds}')
print('Payout curve verification passed')
"
```
</verification>

<success_criteria>
1. PowerLawPayoutCurve and ExponentialPayoutCurve implement predict() method
2. PayoutCurveFitter fits curves using scipy.optimize.curve_fit
3. Fit quality metrics (R², RMSE) computed correctly
4. Contest Pydantic models validate all input data
5. Payout curve utilities work with historical data
6. Unit tests pass for all components
</success_criteria>

<output>
After completion, create `.planning/phases/04-field-ownership-contest-sim/04-03-SUMMARY.md`
</output>
